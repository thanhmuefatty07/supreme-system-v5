{"dependencies": [{"name": "aiodns", "version": "3.5.0", "vulns": []}, {"name": "aiofiles", "version": "25.1.0", "vulns": []}, {"name": "aiohappyeyeballs", "version": "2.6.1", "vulns": []}, {"name": "aiohttp", "version": "3.13.2", "vulns": []}, {"name": "aiolimiter", "version": "1.1.1", "vulns": []}, {"name": "aioresponses", "version": "0.7.8", "vulns": []}, {"name": "aiosignal", "version": "1.4.0", "vulns": []}, {"name": "altair", "version": "5.5.0", "vulns": []}, {"name": "altgraph", "version": "0.17.4", "vulns": []}, {"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anthropic", "version": "0.72.1", "vulns": []}, {"name": "anyio", "version": "4.11.0", "vulns": []}, {"name": "argon2-cffi-bindings", "version": "25.1.0", "vulns": []}, {"name": "asttokens", "version": "3.0.0", "vulns": []}, {"name": "astunparse", "version": "1.6.3", "vulns": []}, {"name": "async-lru", "version": "2.0.5", "vulns": []}, {"name": "async-timeout", "version": "4.0.3", "vulns": []}, {"name": "asyncio-throttle", "version": "1.0.2", "vulns": []}, {"name": "asyncpg", "version": "0.30.0", "vulns": []}, {"name": "attrs", "version": "25.4.0", "vulns": []}, {"name": "authlib", "version": "1.6.3", "vulns": [{"id": "GHSA-9ggr-2464-2j32", "fix_versions": ["1.6.4"], "aliases": ["CVE-2025-59420"], "description": "## Summary Authlib\u2019s JWS verification accepts tokens that declare unknown critical header parameters (`crit`), violating RFC 7515 \u201cmust\u2011understand\u201d semantics. An attacker can craft a signed token with a critical header (for example, `bork` or `cnf`) that strict verifiers reject but Authlib accepts. In mixed\u2011language fleets, this enables split\u2011brain verification and can lead to policy bypass, replay, or privilege escalation.  ## Affected Component and Versions - Library: Authlib (JWS verification) - API: `authlib.jose.JsonWebSignature.deserialize_compact(...)` - Version tested: 1.6.3 - Configuration: Default; no allowlist or special handling for `crit`  ## Details RFC 7515 (JWS) \u00a74.1.11 defines `crit` as a \u201cmust\u2011understand\u201d list: recipients MUST understand and enforce every header parameter listed in `crit`, otherwise they MUST reject the token. Security\u2011sensitive semantics such as token binding (e.g., `cnf` from RFC 7800) are often conveyed via `crit`.  Observed behavior with Authlib 1.6.3: - When a compact JWS contains a protected header with `crit: [\"cnf\"]` and a `cnf` object, or `crit: [\"bork\"]` with an unknown parameter, Authlib verifies the signature and returns the payload without rejecting the token or enforcing semantics of the critical parameter. - By contrast, Java Nimbus JOSE+JWT (9.37.x) and Node `jose` v5 both reject such tokens by default when `crit` lists unknown names.  Impact in heterogeneous fleets: - A strict ingress/gateway (Nimbus/Node) rejects a token, but a lenient Python microservice (Authlib) accepts the same token. This split\u2011brain acceptance bypasses intended security policies and can enable replay or privilege escalation if `crit` carries binding or policy information.  ## Proof of Concept (PoC) This repository provides a multi\u2011runtime PoC demonstrating the issue across Python (Authlib), Node (`jose` v5), and Java (Nimbus).  ### Prerequisites - Python 3.8+ - Node.js 18+ - Java 11+ with Maven  ### Setup  Enter the directory **authlib-crit-bypass-poc** & run following commands. ```bash make setup make tokens ```  ### Tokens minted - `tokens/unknown_crit.jwt` with protected header:   `{ \"alg\": \"HS256\", \"crit\": [\"bork\"], \"bork\": \"x\" }` - `tokens/cnf_header.jwt` with protected header:   `{ \"alg\": \"HS256\", \"crit\": [\"cnf\"], \"cnf\": {\"jkt\": \"thumb-42\"} }`  ### Reproduction Run the cross\u2011runtime demo: ```bash make  demo ```  Expected output for each token (strict verifiers reject; Authlib accepts):  For `tokens/unknown_crit.jwt`: ``` Strict(Nimbus): REJECTED (unknown critical header: bork) Strict(Node jose): REJECTED (unrecognized crit) Lenient(Authlib): ACCEPTED -> payload={'sub': '123', 'role': 'user'} ```  For `tokens/cnf_header.jwt`: ``` Strict(Nimbus): REJECTED (unknown critical header: cnf) Strict(Node jose): REJECTED (unrecognized crit) Lenient(Authlib): ACCEPTED -> payload={'sub': '123', 'role': 'user'} ```  Environment notes: - Authlib version used: `1.6.3` (from PyPI) - Node `jose` version: `^5` - Nimbus JOSE+JWT version: `9.37.x` - HS256 secret is 32 bytes to satisfy strict verifiers: `0123456789abcdef0123456789abcdef`  ## Impact - Class: Violation of JWS `crit` \u201cmust\u2011understand\u201d semantics; specification non\u2011compliance leading to authentication/authorization policy bypass. - Who is impacted: Any service that relies on `crit` to carry mandatory security semantics (e.g., token binding via `cnf`) or operates in a heterogeneous fleet with strict verifiers elsewhere. - Consequences: Split\u2011brain acceptance (gateway rejects while a backend accepts), replay, or privilege escalation if critical semantics are ignored.  ## References - RFC 7515: JSON Web Signature (JWS), \u00a74.1.11 `crit` - RFC 7800: Proof\u2011of\u2011Possession Key Semantics for JWTs (`cnf`)"}, {"id": "GHSA-pq5p-34cr-23v9", "fix_versions": ["1.6.5"], "aliases": ["CVE-2025-61920"], "description": "**Summary** Authlib\u2019s JOSE implementation accepts unbounded JWS/JWT header and signature segments. A remote attacker can craft a token whose base64url\u2011encoded header or signature spans hundreds of megabytes. During verification, Authlib decodes and parses the full input before it is rejected, driving CPU and memory consumption to hostile levels and enabling denial of service.  **Impact**  - Attack vector: unauthenticated network attacker submits a malicious JWS/JWT.  - Effect: base64 decode + JSON/crypto processing of huge buffers pegs CPU and allocates large amounts of RAM; a single request can exhaust service capacity.  - Observed behaviour: on a test host, the legacy code verified a 500\u202fMB header, consuming ~4\u202fGB RSS and ~9\u202fs CPU before failing.  - Severity: High. CVSS v3.1: AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H (7.5).  Affected Versions Authlib \u2264\u202f1.6.3 (and earlier) when verifying JWS/JWT tokens. Later snapshots with 256\u202fKB header/signature limits are not affected.  **Proof of concept**  Local demo (do not run against third-party systems): Download [jws_segment_dos_demo.py](https://github.com/user-attachments/files/22450820/jws_segment_dos_demo.py) the PoC in direcotry authlib/ Run following Command ``` python3 jws_segment_dos_demo.py --variant both --sizes \"500MB\" --fork-per-case  ``` Environment: Python 3.13.6, Authlib 1.6.4, Linux x86_64, CPUs=8  Sample output: Refined <img width=\"1295\" height=\"306\" alt=\"image\" src=\"https://github.com/user-attachments/assets/6dd8410f-bc36-4717-8cee-649bac9bf291\" />     The compilation script prints separate \u201c[ATTACKER]\u201d (token construction) and \u201c[SERVER]\u201d (Authlib verification) RSS deltas so defenders can distinguish client-side preparation from server-side amplification. Regression tests authlib/tests/dos/test_jose_dos.py further capture the issue; the saved original_util.py/original_jws.py reproductions still accept the malicious payload.  **Remediation**  - Apply the upstream patch that introduces decoded size limits:  - MAX_HEADER_SEGMENT_BYTES = 256 KB  - MAX_SIGNATURE_SEGMENT_BYTES = 256 KB  - Enforce Limits in authlib/jose/util.extract_segment and _extract_signature.  - Deploy the patched release immediately.  - For additional defence in depth, reject JWS/JWT inputs above a few kilobytes at the proxy or WAF layer, and rate-limit verification endpoints.  **Workarounds (temporary)**  - Enforce input size limits before handing tokens to Authlib.  - Use application-level throttling to reduce amplification risk.  **Resources**  - Demo script: jws_segment_dos_demo.py  - Tests: authlib/tests/dos/test_jose_dos.py  - OWASP JWT Cheat Sheet (DoS guidance)"}, {"id": "GHSA-g7f3-828f-7h7m", "fix_versions": ["1.6.5"], "aliases": ["CVE-2025-62706"], "description": "### Summary _Authlib\u2019s JWE `zip=DEF` path performs unbounded DEFLATE decompression. A very small ciphertext can expand into tens or hundreds of megabytes on decrypt, allowing an attacker who can supply decryptable tokens to exhaust memory and CPU and cause denial of service._  ### Details - Affected component: Authlib JOSE, JWE `zip=DEF` (DEFLATE) support. - In `authlib/authlib/jose/rfc7518/jwe_zips.py`, `DeflateZipAlgorithm.decompress` calls `zlib.decompress(s, -zlib.MAX_WBITS)` without a maximum output limit. This permits unbounded expansion of compressed payloads. - In the JWE decode flow (`authlib/authlib/jose/rfc7516/jwe.py`), when the protected header contains `\"zip\": \"DEF\"`, the library routes the decrypted ciphertext into the `decompress` method and assigns the fully decompressed bytes to the plaintext field before returning it. No streaming limit or quota is applied. - Because DEFLATE achieves extremely high ratios on highly repetitive input, an attacker can craft a tiny `zip=DEF` ciphertext that inflates to a very large plaintext during decrypt, spiking RSS and CPU. Repeated requests can starve the process or host.  Code references (from this repository version): - `authlib/authlib/jose/rfc7518/jwe_zips.py` \u2013 `DeflateZipAlgorithm.decompress` uses unbounded `zlib.decompress`. - `authlib/authlib/jose/rfc7516/jwe.py` \u2013 JWE decode path applies `zip_.decompress(msg)` when `zip=DEF` is present in the header.  Contrast: The `joserfc` project guards `zip=DEF` decompression with a fixed maximum (256 KB) and raises `ExceededSizeError` if output would exceed this limit, preventing the bomb. Authlib lacks such a guard in this codebase snapshot.  ### PoC Environment: Python 3.10+ inside a venv; Authlib installed editable from this repository so source changes are visible. The PoC script demonstrates both a benign and a compressible-bomb payload and prints wall/CPU time, RSS, and size ratios.  1) Create venv and install Authlib (editable): Set current directory to /authlib Download [jwe_deflate_dos_demo.py](https://github.com/user-attachments/files/22519553/jwe_deflate_dos_demo.py) in /authlib ``` python3 -m venv .venv .venv/bin/pip install --upgrade pip .venv/bin/pip install -e . ```  2) Run the PoC (included in this repo): ``` .venv/bin/python /authlib/jwe_deflate_dos_demo.py --size 50 --max-rss-mb 2048 ```  Sample output (abridged): ``` LOCAL TEST ONLY \u2013 do not send to third-party systems. Runtime: Python 3.13.6 / Authlib 1.6.4 / zip=DEF via A256GCM [CASE] normal    plaintext=13B  ciphertext=117B decompressed=13B  wall_s=0.000 cpu_s=0.000 peak_rss_mb=31.0  ratio=0.1 [CASE] malicious plaintext=50MB ciphertext=~4KB decompressed=50MB wall_s=~2.3  cpu_s=~2.2  peak_rss_mb=800+  ratio=12500+ ```  The second case shows the decompression spike: a few KB of ciphertext forces allocation and processing of ~50 MB during decrypt. Repeated requests can quickly exhaust available memory and CPU.  Reproduction notes: - Algorithm: `alg=dir`, `enc=A256GCM`, header includes `{ \"zip\": \"DEF\" }`. - The PoC uses a 32\u2011byte local symmetric key and a highly compressible payload (`\"A\" * N`). - Increase `--size` to stress memory; the `--max-rss-mb` flag helps avoid destabilizing the host during testing.  ### Impact - Effect: Denial of service (memory/CPU exhaustion) during JWE decrypt of `zip=DEF` tokens. - Who is impacted: Any service that uses Authlib to decrypt JWE tokens with `zip=DEF` and where an attacker can submit tokens that will be successfully decrypted (e.g., shared `dir` key, token reflection, or compromised/abused issuers). - Confidentiality/Integrity: No direct C/I impact; availability impact is high.  ### Severity (CVSS v3.1) Base vector (typical shared\u2011secret scenario where the attacker must produce a decryptable token): - `CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H` \u2192 6.5 (MEDIUM)  **Rationale:** - Network\u2011reachable (AV:N), low complexity (AC:L), no user interaction (UI:N), scope unchanged (S:U). - Attacker must hold or gain ability to mint a decryptable token for the target (PR:L) \u2014 common with `alg=dir` and shared keys across services. - No confidentiality or integrity loss (C:N/I:N); availability is severely impacted (A:H) due to decompression expansion. If arbitrary unprivileged parties can submit JWEs that will be decrypted (PR:N), the base vector becomes: - `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H` \u2192 7.5 (HIGH)  ### Mitigations / Workarounds - Reject or strip `zip=DEF` for inbound JWEs at the application boundary until a fix is available. - Fork and add a bounded decompression guard (e.g., `zlib.decompress(..., max_length)` via `decompressobj().decompress(data, MAX_SIZE)`), returning an error when output exceeds a safe limit. - Enforce strict maximum token sizes and fail fast on oversized inputs; combine with rate limiting.  ### Remediation Guidance (for maintainers) - Mirror `joserfc`\u2019s approach: add a conservative maximum output size (e.g., 256 KB by default) and raise a specific error when exceeded; document a controlled way to raise this ceiling for trusted environments. - Consider streaming decode with chunked limits to avoid large single allocations.  ### References - Authlib source: `authlib/authlib/jose/rfc7518/jwe_zips.py`, `authlib/authlib/jose/rfc7516/jwe.py`"}]}, {"name": "bandit", "version": "1.8.5", "vulns": []}, {"name": "bayesian-optimization", "version": "3.1.0", "vulns": []}, {"name": "bcrypt", "version": "5.0.0", "vulns": []}, {"name": "beautifulsoup4", "version": "4.14.2", "vulns": []}, {"name": "black", "version": "23.12.1", "vulns": [{"id": "PYSEC-2024-48", "fix_versions": ["24.3.0"], "aliases": ["CVE-2024-21503"], "description": "Versions of the package black before 24.3.0 are vulnerable to Regular Expression Denial of Service (ReDoS) via the lines_with_leading_tabs_expanded function in the strings.py file. An attacker could exploit this vulnerability by crafting a malicious input that causes a denial of service.\r\rExploiting this vulnerability is possible when running Black on untrusted input, or if you habitually put thousands of leading tab characters in your docstrings."}]}, {"name": "blinker", "version": "1.9.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "build", "version": "1.3.0", "vulns": []}, {"name": "cachecontrol", "version": "0.14.3", "vulns": []}, {"name": "cachetools", "version": "5.5.2", "vulns": []}, {"name": "ccxt", "version": "4.5.15", "vulns": []}, {"name": "certifi", "version": "2025.10.5", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "cfgv", "version": "3.4.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.4", "vulns": []}, {"name": "circuitbreaker", "version": "2.1.3", "vulns": []}, {"name": "click", "version": "8.3.0", "vulns": []}, {"name": "cloudpickle", "version": "3.1.1", "vulns": []}, {"name": "cma", "version": "4.3.0", "vulns": []}, {"name": "colorama", "version": "0.4.6", "vulns": []}, {"name": "colorlog", "version": "6.9.0", "vulns": []}, {"name": "comm", "version": "0.2.3", "vulns": []}, {"name": "contourpy", "version": "1.3.3", "vulns": []}, {"name": "coverage", "version": "7.9.1", "vulns": []}, {"name": "cryptography", "version": "46.0.3", "vulns": []}, {"name": "cssselect2", "version": "0.8.0", "vulns": []}, {"name": "cupy-cuda12x", "version": "13.6.0", "vulns": []}, {"name": "curl-cffi", "version": "0.13.0", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "9.1.0", "vulns": []}, {"name": "databricks-sdk", "version": "0.60.0", "vulns": []}, {"name": "dateparser", "version": "1.2.2", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "dependency-injector", "version": "4.48.2", "vulns": []}, {"name": "detect-secrets", "version": "1.5.0", "vulns": []}, {"name": "dill", "version": "0.4.0", "vulns": []}, {"name": "diskcache", "version": "5.6.3", "vulns": []}, {"name": "distlib", "version": "0.4.0", "vulns": []}, {"name": "distro", "version": "1.9.0", "vulns": []}, {"name": "dnspython", "version": "2.7.0", "vulns": []}, {"name": "docker", "version": "7.1.0", "vulns": []}, {"name": "docstring-parser", "version": "0.17.0", "vulns": []}, {"name": "docutils", "version": "0.18.1", "vulns": []}, {"name": "dparse", "version": "0.6.4", "vulns": []}, {"name": "email-validator", "version": "2.3.0", "vulns": []}, {"name": "entrypoints", "version": "0.4", "vulns": []}, {"name": "execnet", "version": "2.1.1", "vulns": []}, {"name": "farama-notifications", "version": "0.0.4", "vulns": []}, {"name": "fastapi-cli", "version": "0.0.8", "vulns": []}, {"name": "fastjsonschema", "version": "2.21.2", "vulns": []}, {"name": "fastrlock", "version": "0.8.3", "vulns": []}, {"name": "feedparser", "version": "6.0.11", "vulns": []}, {"name": "filelock", "version": "3.20.0", "vulns": []}, {"name": "finta", "version": "1.3", "vulns": []}, {"name": "flake8", "version": "6.1.0", "vulns": []}, {"name": "flatbuffers", "version": "25.2.10", "vulns": []}, {"name": "fqdn", "version": "1.5.1", "vulns": []}, {"name": "freqtrade", "version": "2025.9.1", "vulns": []}, {"name": "freqtrade-client", "version": "2025.9.1", "vulns": []}, {"name": "frozendict", "version": "2.4.6", "vulns": []}, {"name": "frozenlist", "version": "1.8.0", "vulns": []}, {"name": "ft-pandas-ta", "version": "0.3.16", "vulns": []}, {"name": "gast", "version": "0.6.0", "vulns": []}, {"name": "gitdb", "version": "4.0.12", "vulns": []}, {"name": "gitpython", "version": "3.1.45", "vulns": []}, {"name": "google-ai-generativelanguage", "version": "0.6.15", "vulns": []}, {"name": "google-api-core", "version": "2.28.1", "vulns": []}, {"name": "google-api-python-client", "version": "2.187.0", "vulns": []}, {"name": "google-auth", "version": "2.40.3", "vulns": []}, {"name": "google-auth-httplib2", "version": "0.2.1", "vulns": []}, {"name": "google-generativeai", "version": "0.8.5", "vulns": []}, {"name": "google-pasta", "version": "0.2.0", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.72.0", "vulns": []}, {"name": "graphene", "version": "3.4.3", "vulns": []}, {"name": "graphql-core", "version": "3.2.6", "vulns": []}, {"name": "graphql-relay", "version": "3.2.0", "vulns": []}, {"name": "grpcio", "version": "1.74.0", "vulns": []}, {"name": "grpcio-status", "version": "1.71.2", "vulns": []}, {"name": "gunicorn", "version": "23.0.0", "vulns": []}, {"name": "guppy3", "version": "3.1.5", "vulns": []}, {"name": "gymnasium", "version": "0.29.1", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "hmmlearn", "version": "0.3.3", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httplib2", "version": "0.31.0", "vulns": []}, {"name": "httptools", "version": "0.6.4", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "humanize", "version": "4.14.0", "vulns": []}, {"name": "hypothesis", "version": "6.86.0", "vulns": []}, {"name": "identify", "version": "2.6.15", "vulns": []}, {"name": "idna", "version": "3.11", "vulns": []}, {"name": "iniconfig", "version": "2.1.0", "vulns": []}, {"name": "instructor", "version": "1.13.0", "vulns": []}, {"name": "ipython-pygments-lexers", "version": "1.1.1", "vulns": []}, {"name": "isoduration", "version": "20.11.0", "vulns": []}, {"name": "isort", "version": "5.13.2", "vulns": []}, {"name": "itsdangerous", "version": "2.2.0", "vulns": []}, {"name": "janus", "version": "2.0.0", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "jiter", "version": "0.11.1", "vulns": []}, {"name": "joblib", "version": "1.5.2", "vulns": []}, {"name": "jsonpointer", "version": "3.0.0", "vulns": []}, {"name": "jsonschema", "version": "4.25.1", "vulns": []}, {"name": "jsonschema-specifications", "version": "2025.4.1", "vulns": []}, {"name": "jupyter-events", "version": "0.12.0", "vulns": []}, {"name": "jupyter-lsp", "version": "2.3.0", "vulns": []}, {"name": "jupyter-server-terminals", "version": "0.5.3", "vulns": []}, {"name": "keras", "version": "3.11.3", "vulns": [{"id": "GHSA-mq84-hjqx-cwf2", "fix_versions": ["3.12.0"], "aliases": ["CVE-2025-12058"], "description": "The Keras.Model.load_model method, including when executed with the intended security mitigation safe_mode=True, is vulnerable to arbitrary local file loading and Server-Side Request Forgery (SSRF).   This vulnerability stems from the way the StringLookup layer is handled during model loading from a specially crafted .keras archive. The constructor for the StringLookup layer accepts a vocabulary argument that can specify a local file path or a remote file path.    *  Arbitrary Local File Read: An attacker can create a malicious .keras file that embeds a local path in the StringLookup layer's configuration. When the model is loaded, Keras will attempt to read the content of the specified local file and incorporate it into the model state (e.g., retrievable via get_vocabulary()), allowing an attacker to read arbitrary local files on the hosting system.     *  Server-Side Request Forgery (SSRF): Keras utilizes tf.io.gfile for file operations. Since tf.io.gfile supports remote filesystem handlers (such as GCS and HDFS) and HTTP/HTTPS protocols, the same mechanism can be leveraged to fetch content from arbitrary network endpoints on the server's behalf, resulting in an SSRF condition.   The security issue is that the feature allowing external path loading was not properly restricted by the safe_mode=True flag, which was intended to prevent such unintended data access."}, {"id": "GHSA-28jp-44vh-q42h", "fix_versions": ["3.12.0"], "aliases": ["CVE-2025-12060"], "description": "The keras.utils.get_file API in Keras, when used with the extract=True option for tar archives, is vulnerable to a path traversal attack. The utility uses Python's tarfile.extractall function without the filter=\"data\" feature. A remote attacker can craft a malicious tar archive containing special symlinks, which, when extracted, allows them to write arbitrary files to any location on the filesystem outside of the intended destination folder. This vulnerability is linked to the underlying Python tarfile weakness, identified as CVE-2025-4517.\u00a0Note that upgrading Python to one of the versions that fix CVE-2025-4517 (e.g. Python 3.13.4) is not enough. One additionally needs to upgrade Keras to a version with the fix (Keras 3.12)."}]}, {"name": "lark", "version": "1.2.2", "vulns": []}, {"name": "libclang", "version": "18.1.1", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "lightning", "version": "2.5.3", "vulns": []}, {"name": "lightning-utilities", "version": "0.15.2", "vulns": []}, {"name": "llvmlite", "version": "0.45.1", "vulns": []}, {"name": "loguru", "version": "0.7.3", "vulns": []}, {"name": "mako", "version": "1.3.10", "vulns": []}, {"name": "markdown", "version": "3.8.2", "vulns": []}, {"name": "markdown-it-py", "version": "3.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.3", "vulns": []}, {"name": "marshmallow", "version": "4.0.1", "vulns": []}, {"name": "matplotlib-inline", "version": "0.1.7", "vulns": []}, {"name": "mccabe", "version": "0.7.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "memory-profiler", "version": "0.61.0", "vulns": []}, {"name": "ml-dtypes", "version": "0.5.3", "vulns": []}, {"name": "mlflow", "version": "2.13.2", "vulns": [{"id": "PYSEC-2025-17", "fix_versions": ["2.19.0"], "aliases": ["CVE-2025-1474"], "description": "In mlflow/mlflow version 2.18, an admin is able to create a new user account without setting a password. This vulnerability could lead to security risks, as accounts without passwords may be susceptible to unauthorized access. Additionally, this issue violates best practices for secure user account management. The issue is fixed in version 2.19.0."}, {"id": "PYSEC-2024-224", "fix_versions": ["2.16.0"], "aliases": ["CVE-2024-27134"], "description": "Excessive directory permissions in MLflow leads to local privilege escalation when using spark_udf. This behavior can be exploited by a local attacker to gain elevated permissions by using a ToCToU attack. The issue is only relevant when the spark_udf() MLflow API is called."}, {"id": "PYSEC-2025-52", "fix_versions": ["3.1.0"], "aliases": ["CVE-2025-52967"], "description": "gateway_proxy_handler in MLflow before 3.1.0 lacks gateway_path validation."}, {"id": "GHSA-x38x-g6gr-jqff", "fix_versions": [], "aliases": ["CVE-2024-37055"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 1.24.0 or newer, enabling a maliciously uploaded pmdarima model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-j8mg-pqc5-x9gj", "fix_versions": [], "aliases": ["CVE-2024-37057"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 2.0.0rc0 or newer, enabling a maliciously uploaded Tensorflow model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-ghv6-9r9j-wh4j", "fix_versions": [], "aliases": ["CVE-2024-37054"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 0.9.0 or newer, enabling a maliciously uploaded PyFunc model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-cv6c-7963-wxcg", "fix_versions": [], "aliases": ["CVE-2024-37060"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 1.27.0 or newer, enabling a maliciously crafted Recipe to execute arbitrary code on an end user\u2019s system when run."}, {"id": "GHSA-76cg-cfhx-373f", "fix_versions": [], "aliases": ["CVE-2024-37052"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 1.1.0 or newer, enabling a maliciously uploaded scikit-learn model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-wf7f-8fxf-xfxc", "fix_versions": [], "aliases": ["CVE-2024-37059"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 0.5.0 or newer, enabling a maliciously uploaded PyTorch model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-cwgg-w6mp-w9hg", "fix_versions": [], "aliases": ["CVE-2024-37058"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 2.5.0 or newer, enabling a maliciously uploaded Langchain AgentExecutor model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-43c4-9qgj-x742", "fix_versions": [], "aliases": ["CVE-2024-37053"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 1.1.0 or newer, enabling a maliciously uploaded scikit-learn model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-7p8j-qv6x-f4g4", "fix_versions": [], "aliases": ["CVE-2024-37056"], "description": "Deserialization of untrusted data can occur in versions of the MLflow platform running version 1.23.0 or newer, enabling a maliciously uploaded LightGBM scikit-learn model to run arbitrary code on an end user\u2019s system when interacted with."}, {"id": "GHSA-4rqf-8pfm-p36r", "fix_versions": ["2.17.0rc0"], "aliases": ["CVE-2024-8859"], "description": "A path traversal vulnerability exists in mlflow/mlflow version 2.15.1. When users configure and use the dbfs service, concatenating the URL directly into the file protocol results in an arbitrary file read vulnerability. This issue occurs because only the path part of the URL is checked, while parts such as query and parameters are not handled. The vulnerability is triggered if the user has configured the dbfs service, and during usage, the service is mounted to a local directory."}, {"id": "GHSA-q3gw-8236-5jw4", "fix_versions": [], "aliases": ["CVE-2024-6838"], "description": "In mlflow/mlflow version v2.13.2, a vulnerability exists that allows the creation or renaming of an experiment with a large number of integers in its name due to the lack of a limit on the experiment name. This can cause the MLflow UI panel to become unresponsive, leading to a potential denial of service. Additionally, there is no character limit in the `artifact_location` parameter while creating the experiment."}, {"id": "GHSA-49m6-vrr9-2cqm", "fix_versions": [], "aliases": ["CVE-2025-0453"], "description": "In mlflow/mlflow version 2.17.2, the `/graphql` endpoint is vulnerable to a denial of service attack. An attacker can create large batches of queries that repeatedly request all runs from a given experiment. This can tie up all the workers allocated by MLFlow, rendering the application unable to respond to other requests. This vulnerability is due to uncontrolled resource consumption."}, {"id": "GHSA-6xj8-rrqx-r4cv", "fix_versions": ["2.22.0"], "aliases": ["CVE-2025-11200"], "description": "MLflow Weak Password Requirements Authentication Bypass Vulnerability. This vulnerability allows remote attackers to bypass authentication on affected installations of MLflow. Authentication is not required to exploit this vulnerability.  The specific flaw exists within the handling of passwords. The issue results from weak password requirements. An attacker can leverage this vulnerability to bypass authentication on the system. Was ZDI-CAN-26916."}, {"id": "GHSA-5cvj-7rg6-jggj", "fix_versions": ["3.0.0"], "aliases": ["CVE-2025-11201"], "description": "MLflow Tracking Server Model Creation Directory Traversal Remote Code Execution Vulnerability. This vulnerability allows remote attackers to execute arbitrary code on affected installations of MLflow Tracking Server. Authentication is not required to exploit this vulnerability.  The specific flaw exists within the handling of model file paths. The issue results from the lack of proper validation of a user-supplied path prior to using it in file operations. An attacker can leverage this vulnerability to execute code in the context of the service account. Was ZDI-CAN-26921."}]}, {"name": "mlflow-skinny", "version": "3.1.4", "vulns": []}, {"name": "msgpack", "version": "1.0.8", "vulns": []}, {"name": "multidict", "version": "6.7.0", "vulns": []}, {"name": "multitasking", "version": "0.0.12", "vulns": []}, {"name": "mypy", "version": "1.7.1", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "namex", "version": "0.1.0", "vulns": []}, {"name": "narwhals", "version": "1.44.0", "vulns": []}, {"name": "nevergrad", "version": "0.11.0", "vulns": []}, {"name": "nltk", "version": "3.9.1", "vulns": []}, {"name": "nodeenv", "version": "1.9.1", "vulns": []}, {"name": "notebook-shim", "version": "0.2.4", "vulns": []}, {"name": "numba", "version": "0.62.1", "vulns": []}, {"name": "numpy", "version": "2.3.4", "vulns": []}, {"name": "oauthlib", "version": "3.3.1", "vulns": []}, {"name": "openai", "version": "2.7.2", "vulns": []}, {"name": "opentelemetry-api", "version": "1.35.0", "vulns": []}, {"name": "opentelemetry-sdk", "version": "1.35.0", "vulns": []}, {"name": "opentelemetry-semantic-conventions", "version": "0.56b0", "vulns": []}, {"name": "opt-einsum", "version": "3.4.0", "vulns": []}, {"name": "optree", "version": "0.17.0", "vulns": []}, {"name": "optuna", "version": "3.6.2", "vulns": []}, {"name": "oqs", "version": "0.10.2", "vulns": []}, {"name": "ordered-set", "version": "4.1.0", "vulns": []}, {"name": "orjson", "version": "3.11.3", "vulns": []}, {"name": "outcome", "version": "1.3.0.post0", "vulns": []}, {"name": "overrides", "version": "7.7.0", "vulns": []}, {"name": "packageurl-python", "version": "0.17.5", "vulns": []}, {"name": "packaging", "version": "24.2", "vulns": []}, {"name": "paho-mqtt", "version": "2.1.0", "vulns": []}, {"name": "pandas", "version": "2.3.3", "vulns": []}, {"name": "pandas-ta", "skip_reason": "Dependency not found on PyPI and could not be audited: pandas-ta (0.3.14b0)"}, {"name": "passlib", "version": "1.7.4", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "pbr", "version": "6.1.1", "vulns": []}, {"name": "pdfkit", "version": "1.0.0", "vulns": []}, {"name": "peewee", "version": "3.18.2", "vulns": []}, {"name": "pefile", "version": "2023.2.7", "vulns": []}, {"name": "pika", "version": "1.3.2", "vulns": []}, {"name": "pillow", "version": "10.4.0", "vulns": []}, {"name": "pip", "version": "25.3", "vulns": []}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.9.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "platformdirs", "version": "4.5.0", "vulns": []}, {"name": "plotly", "version": "6.4.0", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "polars", "version": "1.33.1", "vulns": []}, {"name": "pre-commit", "version": "4.3.0", "vulns": []}, {"name": "prometheus-client", "version": "0.17.1", "vulns": []}, {"name": "propcache", "version": "0.4.1", "vulns": []}, {"name": "proto-plus", "version": "1.26.1", "vulns": []}, {"name": "protobuf", "version": "5.29.5", "vulns": []}, {"name": "psutil", "version": "5.9.8", "vulns": []}, {"name": "psycopg2-binary", "version": "2.9.9", "vulns": []}, {"name": "py-cpuinfo", "version": "9.0.0", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyarrow", "version": "22.0.0", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": []}, {"name": "pyasn1-modules", "version": "0.4.2", "vulns": []}, {"name": "pybit", "version": "5.11.0", "vulns": []}, {"name": "pycares", "version": "4.10.0", "vulns": []}, {"name": "pycodestyle", "version": "2.11.1", "vulns": []}, {"name": "pycoingecko", "version": "3.2.0", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pycryptodome", "version": "3.23.0", "vulns": []}, {"name": "pydantic", "version": "2.12.3", "vulns": []}, {"name": "pydantic-core", "version": "2.41.4", "vulns": []}, {"name": "pydantic-settings", "version": "2.1.0", "vulns": []}, {"name": "pydeck", "version": "0.9.1", "vulns": []}, {"name": "pydyf", "version": "0.11.0", "vulns": []}, {"name": "pyflakes", "version": "3.1.0", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyinstaller", "version": "6.14.1", "vulns": []}, {"name": "pyinstaller-hooks-contrib", "version": "2025.5", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pylatex", "version": "1.4.2", "vulns": []}, {"name": "pylint", "version": "3.3.8", "vulns": []}, {"name": "pyotp", "version": "2.9.0", "vulns": []}, {"name": "pyparsing", "version": "3.2.5", "vulns": []}, {"name": "pyphen", "version": "0.17.2", "vulns": []}, {"name": "pyproject-hooks", "version": "1.2.0", "vulns": []}, {"name": "pytest", "version": "7.4.4", "vulns": []}, {"name": "pytest-asyncio", "version": "0.21.2", "vulns": []}, {"name": "pytest-benchmark", "version": "4.0.0", "vulns": []}, {"name": "pytest-cov", "version": "6.2.1", "vulns": []}, {"name": "pytest-mock", "version": "3.15.1", "vulns": []}, {"name": "pytest-xdist", "version": "3.8.0", "vulns": []}, {"name": "python-binance", "version": "1.0.32", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-dotenv", "version": "1.0.0", "vulns": []}, {"name": "python-multipart", "version": "0.0.20", "vulns": []}, {"name": "python-rapidjson", "version": "1.22", "vulns": []}, {"name": "python-slugify", "version": "8.0.4", "vulns": []}, {"name": "python-telegram-bot", "version": "22.5", "vulns": []}, {"name": "pytorch-forecasting", "version": "1.4.0", "vulns": []}, {"name": "pytorch-lightning", "version": "2.5.3", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pywin32-ctypes", "version": "0.2.3", "vulns": []}, {"name": "pyyaml", "version": "6.0.2", "vulns": []}, {"name": "querystring-parser", "version": "1.2.4", "vulns": []}, {"name": "questionary", "version": "2.1.1", "vulns": []}, {"name": "redis", "version": "4.6.0", "vulns": []}, {"name": "referencing", "version": "0.36.2", "vulns": []}, {"name": "regex", "version": "2025.11.3", "vulns": []}, {"name": "reportlab", "version": "4.2.5", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "rfc3987-syntax", "version": "1.1.0", "vulns": []}, {"name": "rich", "version": "13.9.4", "vulns": []}, {"name": "rich-toolkit", "version": "0.15.0", "vulns": []}, {"name": "rpds-py", "version": "0.26.0", "vulns": []}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "ruamel-yaml-clib", "version": "0.2.12", "vulns": []}, {"name": "ruff", "version": "0.1.15", "vulns": []}, {"name": "safetensors", "version": "0.6.2", "vulns": []}, {"name": "safety", "version": "3.6.1", "vulns": []}, {"name": "safety-schemas", "version": "0.0.14", "vulns": []}, {"name": "schedule", "version": "1.2.2", "vulns": []}, {"name": "scikit-learn", "version": "1.7.2", "vulns": []}, {"name": "scipy", "version": "1.16.3", "vulns": []}, {"name": "sdnotify", "version": "0.3.2", "vulns": []}, {"name": "seaborn", "version": "0.12.2", "vulns": []}, {"name": "setuptools", "version": "80.9.0", "vulns": []}, {"name": "sgmllib3k", "version": "1.0.0", "vulns": []}, {"name": "shap", "version": "0.48.0", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "simplejson", "version": "3.20.1", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "slicer", "version": "0.0.8", "vulns": []}, {"name": "smmap", "version": "5.0.2", "vulns": []}, {"name": "sniffio", "version": "1.3.1", "vulns": []}, {"name": "snowballstemmer", "version": "3.0.1", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "soupsieve", "version": "2.8", "vulns": []}, {"name": "sphinxcontrib-applehelp", "version": "2.0.0", "vulns": []}, {"name": "sphinxcontrib-devhelp", "version": "2.0.0", "vulns": []}, {"name": "sphinxcontrib-htmlhelp", "version": "2.1.0", "vulns": []}, {"name": "sphinxcontrib-jquery", "version": "4.1", "vulns": []}, {"name": "sphinxcontrib-jsmath", "version": "1.0.1", "vulns": []}, {"name": "sphinxcontrib-qthelp", "version": "2.0.0", "vulns": []}, {"name": "sphinxcontrib-serializinghtml", "version": "2.0.0", "vulns": []}, {"name": "sqlparse", "version": "0.5.3", "vulns": []}, {"name": "stable-baselines3", "version": "2.1.0", "vulns": []}, {"name": "starlette", "version": "0.27.0", "vulns": [{"id": "GHSA-f96h-pmfr-66vw", "fix_versions": ["0.40.0"], "aliases": ["CVE-2024-47874"], "description": "### Summary Starlette treats `multipart/form-data` parts without a `filename` as text form fields and buffers those in byte strings with no size limit. This allows an attacker to upload arbitrary large form fields and cause Starlette to both slow down significantly due to excessive memory allocations and copy operations, and also consume more and more memory until the server starts swapping and grinds to a halt, or the OS terminates the server process with an OOM error. Uploading multiple such requests in parallel may be enough to render a service practically unusable, even if reasonable request size limits are enforced by a reverse proxy in front of Starlette.  ### PoC  ```python from starlette.applications import Starlette from starlette.routing import Route  async def poc(request):     async with request.form():         pass  app = Starlette(routes=[     Route('/', poc, methods=[\"POST\"]), ]) ```  ```sh curl http://localhost:8000 -F 'big=</dev/urandom' ```  ### Impact This Denial of service (DoS) vulnerability affects all applications built with Starlette (or FastAPI) accepting form requests. "}, {"id": "GHSA-2c2j-9gv5-cj73", "fix_versions": ["0.47.2"], "aliases": ["CVE-2025-54121"], "description": "### Summary When parsing a multi-part form with large files (greater than the [default max spool size](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/formparsers.py#L126)) `starlette` will block the main thread to roll the file over to disk. This blocks the event thread which means we can't accept new connections.  ### Details Please see this discussion for details: https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403. In summary the following UploadFile code (copied from [here](https://github.com/encode/starlette/blob/fa5355442753f794965ae1af0f87f9fec1b9a3de/starlette/datastructures.py#L436C5-L447C14)) has a minor bug. Instead of just checking for `self._in_memory` we should also check if the additional bytes will cause a rollover.  ```python      @property     def _in_memory(self) -> bool:         # check for SpooledTemporaryFile._rolled         rolled_to_disk = getattr(self.file, \"_rolled\", True)         return not rolled_to_disk      async def write(self, data: bytes) -> None:         if self.size is not None:             self.size += len(data)          if self._in_memory:             self.file.write(data)         else:             await run_in_threadpool(self.file.write, data) ```  I have already created a PR which fixes the problem: https://github.com/encode/starlette/pull/2962   ### PoC See the discussion [here](https://github.com/encode/starlette/discussions/2927#discussioncomment-13721403) for steps on how to reproduce.  ### Impact To be honest, very low and not many users will be impacted. Parsing large forms is already CPU intensive so the additional IO block doesn't slow down `starlette` that much on systems with modern HDDs/SSDs. If someone is running on tape they might see a greater impact."}]}, {"name": "stevedore", "version": "5.4.1", "vulns": []}, {"name": "streamlit", "version": "1.34.0", "vulns": [{"id": "PYSEC-2024-153", "fix_versions": ["1.37.0"], "aliases": ["GHSA-rxff-vr5r-8cj5", "CVE-2024-42474"], "description": "Streamlit is a data oriented application development framework for python. Snowflake Streamlit open source addressed a security vulnerability via the static file sharing feature. Users of hosted Streamlit app(s) on Windows were vulnerable to a path traversal vulnerability when the static file sharing feature is enabled. An attacker could utilize the vulnerability to leak the password hash of the Windows user running Streamlit. The vulnerability was patched on Jul 25, 2024, as part of Streamlit open source version 1.37.0. The vulnerability only affects Windows."}]}, {"name": "streamlit-aggrid", "version": "0.2.3", "vulns": []}, {"name": "structlog", "version": "23.2.0", "vulns": []}, {"name": "supreme-system-v5", "skip_reason": "Dependency not found on PyPI and could not be audited: supreme-system-v5 (0.1.0)"}, {"name": "ta", "version": "0.11.0", "vulns": []}, {"name": "ta-lib", "version": "0.6.8", "vulns": []}, {"name": "tabulate", "version": "0.9.0", "vulns": []}, {"name": "technical", "version": "1.5.3", "vulns": []}, {"name": "tenacity", "version": "8.4.2", "vulns": []}, {"name": "tensorboard-data-server", "version": "0.7.2", "vulns": []}, {"name": "tensorflow-io-gcs-filesystem", "version": "0.31.0", "vulns": []}, {"name": "text-unidecode", "version": "1.3", "vulns": []}, {"name": "textblob", "version": "0.19.0", "vulns": []}, {"name": "threadpoolctl", "version": "3.6.0", "vulns": []}, {"name": "tinyhtml5", "version": "2.0.0", "vulns": []}, {"name": "toml", "version": "0.10.2", "vulns": []}, {"name": "tomlkit", "version": "0.13.3", "vulns": []}, {"name": "torch-geometric", "version": "2.5.3", "vulns": []}, {"name": "torchaudio", "version": "2.0.1", "vulns": []}, {"name": "torchmetrics", "version": "1.8.1", "vulns": []}, {"name": "torchvision", "version": "0.15.2", "vulns": []}, {"name": "tornado", "version": "6.5.2", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "tslearn", "version": "0.6.4", "vulns": []}, {"name": "ty", "version": "0.0.1a26", "vulns": []}, {"name": "typer", "version": "0.16.1", "vulns": []}, {"name": "types-python-dateutil", "version": "2.9.0.20250822", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "tzdata", "version": "2025.2", "vulns": []}, {"name": "tzlocal", "version": "5.3.1", "vulns": []}, {"name": "ujson", "version": "5.11.0", "vulns": []}, {"name": "uritemplate", "version": "4.2.0", "vulns": []}, {"name": "urllib3", "version": "2.5.0", "vulns": []}, {"name": "uv", "version": "0.9.5", "vulns": [{"id": "GHSA-pqhf-p39g-3x64", "fix_versions": ["0.9.6"], "aliases": [], "description": "### Impact  In versions 0.9.5 and earlier of uv, ZIP archives were handled in a manner that enabled two parsing differentials against other components of the Python packaging ecosystem:  1. Central directory entries in a ZIP archive can contain comment fields. However, uv would assume that these fields were not present, since they aren't widely used. Consequently, a ZIP archive could be constructed where uv would interpret the contents of a central directory comment field as ZIP control structures (such as a new central directory entry), rather than skipping over them. 2. Both local file entries and central directory entries contain filename fields, which are used to place archive members on disk. These fields are arbitrary sequences of bytes, and may therefore be invalid or ambiguous. For example, they may contain ASCII null bytes, in which case different ZIP extractors behave differently: Python's `zipfile` module truncates the filename at the first null, while uv would skip (not extract) any archive members whose filenames contained nulls. Because of this difference, a ZIP archive could be constructed that would extract differently across different Python package installers.  In both cases, the outcome is that an attacker may be able to produce a ZIP with a consistent digest that expands differently with different Python package installers.  Like with GHSA-8qf3-x8v5-2pj8, the impact of these differentials is limited by a number of factors:  - To be compromised via this vulnerability, user interaction of some sort is required. In particular, the user must run `uv pip install $package` or similar with an attacker-controlled $package. When using wheel distributions, installation of the malicious package is not sufficient for execution of malicious code, the vicim would need to perform a separate invocation, e.g., `python -c \"import $package\"`. - If a ZIP-based source distribution (which are less common than tarball source distributions), is encountered, malicious code can be executed during package resolution or installation. uv may invoke the malicious code when building the source distribution into a wheel.  ### Patches  Versions 0.9.6 and newer of uv address both of the parser differentials above, by properly handling comments in central directory entries and by refusing to process ZIPs that contain filename fields that are unlikely to be interpreted consistently across other ZIP parser implementations.  ### Workarounds  Users are advised to upgrade to 0.9.6 or newer to address this advisory.  Most users should experience no breaking changes as a result of the patch above. However, users who do experience breakage should carefully review their distributions for signs of malicious intent. Users may choose to set `UV_INSECURE_NO_ZIP_VALIDATION=1` to revert to the previous behavior.  ### Attribution  This vulnerability was disclosed by Caleb Brown (Google)."}]}, {"name": "vine", "version": "5.1.0", "vulns": []}, {"name": "virtualenv", "version": "20.34.0", "vulns": []}, {"name": "waitress", "version": "3.0.2", "vulns": []}, {"name": "watchdog", "version": "6.0.0", "vulns": []}, {"name": "watchfiles", "version": "1.1.0", "vulns": []}, {"name": "weasyprint", "version": "66.0", "vulns": []}, {"name": "websockets", "version": "15.0.1", "vulns": []}, {"name": "werkzeug", "version": "3.1.3", "vulns": []}, {"name": "wheel", "version": "0.45.1", "vulns": []}, {"name": "win32-setctime", "version": "1.2.0", "vulns": []}, {"name": "wrapt", "version": "1.14.2", "vulns": []}, {"name": "wsproto", "version": "1.2.0", "vulns": []}, {"name": "yarl", "version": "1.22.0", "vulns": []}, {"name": "yfinance", "version": "0.2.66", "vulns": []}, {"name": "zopfli", "version": "0.2.3.post1", "vulns": []}], "fixes": []}
