# python/supreme_system_v5/strategies.py
"""
Trading Strategies - Scalping strategy with EMA and RSI indicators
ULTRA SFL implementation with enterprise-grade signal generation
"""

import statistics
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from loguru import logger
from prometheus_client import Counter, Histogram

# Metrics
SIGNALS_GENERATED = Counter(
    "strategy_signals_total",
    "Signals generated by strategy",
    ["strategy", "signal_type"],
)
SIGNAL_CONFIDENCE = Histogram(
    "strategy_signal_confidence", "Signal confidence distribution", ["strategy"]
)
STRATEGY_LATENCY = Histogram(
    "strategy_latency_seconds", "Strategy calculation latency", ["strategy"]
)


class SignalType(Enum):
    """Trading signal types"""

    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


@dataclass
class TradingSignal:
    """Trading signal with comprehensive metadata"""

    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    entry_price: float
    stop_loss: float
    take_profit: float
    quantity: float
    reasoning: str
    indicators: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)

    def __post_init__(self):
        """Validate signal parameters"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(
                f"Confidence must be between 0.0 and 1.0, got {self.confidence}"
            )

        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive, got {self.quantity}")


@dataclass
class MarketData:
    """Market data structure for strategy calculations"""

    symbol: str
    price: float
    volume: float
    timestamp: float
    bid: Optional[float] = None
    ask: Optional[float] = None
    high_24h: Optional[float] = None
    low_24h: Optional[float] = None


class TechnicalIndicators:
    """Technical indicator calculations with Rust acceleration"""

    @staticmethod
    def calculate_ema(prices: List[float], period: int) -> List[float]:
        """
        Calculate Exponential Moving Average
        Uses Rust implementation for maximum performance
        """
        if len(prices) < period:
            return []

        try:
            # Try Rust implementation first
            import numpy as np
            import supreme_engine_rs

            price_array = np.array(prices, dtype=np.float64)
            result = supreme_engine_rs.fast_ema(price_array, period)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust EMA not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_ema_python(prices, period)

    @staticmethod
    def _calculate_ema_python(prices: List[float], period: int) -> List[float]:
        """Python fallback for EMA calculation"""
        if len(prices) < period:
            return []

        multiplier = 2.0 / (period + 1)
        ema_values = []

        # First EMA is SMA
        sma = sum(prices[:period]) / period
        ema_values.append(sma)

        # Calculate subsequent EMAs
        for price in prices[period:]:
            ema = (price * multiplier) + (ema_values[-1] * (1 - multiplier))
            ema_values.append(ema)

        return ema_values

    @staticmethod
    def calculate_rsi(prices: List[float], period: int = 14) -> List[float]:
        """
        Calculate Relative Strength Index
        Uses Rust implementation for maximum performance
        """
        if len(prices) < period + 1:
            return []

        try:
            # Try Rust implementation first
            import numpy as np
            import supreme_engine_rs

            price_array = np.array(prices, dtype=np.float64)
            result = supreme_engine_rs.fast_rsi(price_array, period)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust RSI not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_rsi_python(prices, period)

    @staticmethod
    def _calculate_rsi_python(prices: List[float], period: int = 14) -> List[float]:
        """Python fallback for RSI calculation"""
        if len(prices) < period + 1:
            return []

        rsi_values = []
        gains = []
        losses = []

        # Calculate price changes
        for i in range(1, len(prices)):
            change = prices[i] - prices[i - 1]
            gains.append(max(change, 0))
            losses.append(max(-change, 0))

        # Calculate initial averages
        avg_gain = sum(gains[:period]) / period
        avg_loss = sum(losses[:period]) / period

        # Calculate first RSI
        if avg_loss == 0:
            rsi = 100.0
        else:
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
        rsi_values.append(rsi)

        # Calculate subsequent RSIs using Wilder's smoothing
        for i in range(period, len(gains)):
            gain = gains[i]
            loss = losses[i]

            avg_gain = ((avg_gain * (period - 1)) + gain) / period
            avg_loss = ((avg_loss * (period - 1)) + loss) / period

            if avg_loss == 0:
                rsi = 100.0
            else:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))

            rsi_values.append(rsi)

        return rsi_values

    @staticmethod
    def calculate_sma(prices: List[float], period: int) -> List[float]:
        """Calculate Simple Moving Average"""
        if len(prices) < period:
            return []

        try:
            # Try Rust implementation first
            import numpy as np
            import supreme_engine_rs

            price_array = np.array(prices, dtype=np.float64)
            result = supreme_engine_rs.fast_sma(price_array, period)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust SMA not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_sma_python(prices, period)

    @staticmethod
    def _calculate_sma_python(prices: List[float], period: int) -> List[float]:
        """Python fallback for SMA calculation"""
        if len(prices) < period:
            return []

        sma_values = []
        for i in range(period - 1, len(prices)):
            sma = sum(prices[i - period + 1 : i + 1]) / period
            sma_values.append(sma)

        return sma_values

    @staticmethod
    def calculate_macd(
        prices: List[float],
        fast_period: int = 12,
        slow_period: int = 26,
        signal_period: int = 9,
    ) -> Tuple[List[float], List[float], List[float]]:
        """Calculate MACD with signal line and histogram"""
        try:
            # Try Rust implementation first
            import numpy as np
            import supreme_engine_rs

            price_array = np.array(prices, dtype=np.float64)
            macd_line, signal_line, histogram = supreme_engine_rs.fast_macd(
                price_array, fast_period, slow_period, signal_period
            )
            return macd_line.tolist(), signal_line.tolist(), histogram.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust MACD not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_macd_python(
                prices, fast_period, slow_period, signal_period
            )

    @staticmethod
    def _calculate_macd_python(
        prices: List[float],
        fast_period: int = 12,
        slow_period: int = 26,
        signal_period: int = 9,
    ) -> Tuple[List[float], List[float], List[float]]:
        """Python fallback for MACD calculation"""
        if len(prices) < slow_period:
            return [], [], []

        # Calculate EMAs
        fast_ema = TechnicalIndicators.calculate_ema(prices, fast_period)
        slow_ema = TechnicalIndicators.calculate_ema(prices, slow_period)

        # Calculate MACD line
        macd_line = []
        for i in range(len(slow_ema)):
            fast_idx = i + (slow_period - fast_period)
            if fast_idx < len(fast_ema):
                macd_line.append(fast_ema[fast_idx] - slow_ema[i])

        # Calculate signal line
        signal_line = TechnicalIndicators.calculate_ema(macd_line, signal_period)

        # Calculate histogram
        histogram = []
        for i in range(len(signal_line)):
            macd_idx = i + (signal_period - 1)
            if macd_idx < len(macd_line):
                histogram.append(macd_line[macd_idx] - signal_line[i])

        return macd_line, signal_line, histogram

    @staticmethod
    def calculate_bollinger_bands(
        prices: List[float], period: int = 20, std_dev: float = 2.0
    ) -> Tuple[List[float], List[float], List[float]]:
        """Calculate Bollinger Bands"""
        try:
            # Try Rust implementation first
            import numpy as np
            import supreme_engine_rs

            price_array = np.array(prices, dtype=np.float64)
            upper_band, middle_band, lower_band = supreme_engine_rs.bollinger_bands(
                price_array, period, std_dev
            )
            return upper_band.tolist(), middle_band.tolist(), lower_band.tolist()

        except (ImportError, Exception) as e:
            logger.debug(
                f"Rust Bollinger Bands not available, using Python fallback: {e}"
            )
            return TechnicalIndicators._calculate_bollinger_bands_python(
                prices, period, std_dev
            )

    @staticmethod
    def _calculate_bollinger_bands_python(
        prices: List[float], period: int = 20, std_dev: float = 2.0
    ) -> Tuple[List[float], List[float], List[float]]:
        """Python fallback for Bollinger Bands calculation"""
        if len(prices) < period:
            return [], [], []

        sma_values = TechnicalIndicators.calculate_sma(prices, period)
        upper_band = []
        lower_band = []

        for i, sma in enumerate(sma_values):
            start_idx = i
            end_idx = i + period

            # Calculate standard deviation
            values = prices[start_idx:end_idx]
            variance = sum((x - sma) ** 2 for x in values) / period
            std = variance**0.5

            upper_band.append(sma + std_dev * std)
            lower_band.append(sma - std_dev * std)

        return upper_band, sma_values, lower_band

    @staticmethod
    def calculate_vwap(
        high: List[float], low: List[float], close: List[float], volume: List[float]
    ) -> List[float]:
        """Calculate Volume Weighted Average Price"""
        try:
            # Try Rust implementation first
            import numpy as np
            import supreme_engine_rs

            high_array = np.array(high, dtype=np.float64)
            low_array = np.array(low, dtype=np.float64)
            close_array = np.array(close, dtype=np.float64)
            volume_array = np.array(volume, dtype=np.float64)

            result = supreme_engine_rs.volume_weighted_average_price(
                high_array, low_array, close_array, volume_array
            )
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust VWAP not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_vwap_python(high, low, close, volume)

    @staticmethod
    def _calculate_vwap_python(
        high: List[float], low: List[float], close: List[float], volume: List[float]
    ) -> List[float]:
        """Python fallback for VWAP calculation"""
        if len(high) != len(low) or len(low) != len(close) or len(close) != len(volume):
            return []

        vwap_values = []
        cumulative_volume = 0.0
        cumulative_volume_price = 0.0

        for i in range(len(close)):
            typical_price = (high[i] + low[i] + close[i]) / 3.0
            volume_price = typical_price * volume[i]

            cumulative_volume += volume[i]
            cumulative_volume_price += volume_price

            if cumulative_volume > 0.0:
                vwap_values.append(cumulative_volume_price / cumulative_volume)
            else:
                vwap_values.append(typical_price)

        return vwap_values


class MultiTimeframeConfirmation:
    """Multi-timeframe analysis for signal confirmation"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {
            "higher_tf_ema_period": 21,  # 21-period EMA on higher timeframe
            "lower_tf_ema_period": 5,    # 5-period EMA on lower timeframe
            "trend_alignment_threshold": 0.7,  # Minimum alignment score
            "higher_tf_weight": 0.6,     # Weight for higher timeframe
            "lower_tf_weight": 0.4,      # Weight for lower timeframe
        }

    def analyze_trend_alignment(self, symbol: str, strategy_instance) -> float:
        """
        Analyze trend alignment across timeframes
        Returns alignment score between 0-1 (1 = perfect alignment)
        """
        try:
            # Get higher timeframe data (simulated - would use different resolution)
            # For now, we'll use a subset of the data to simulate higher TF
            price_history = strategy_instance.price_history.get(symbol, [])
            if len(price_history) < 50:
                return 0.5  # Neutral if insufficient data

            # Simulate higher timeframe by taking every 4th point
            higher_tf_prices = [price for i, (ts, price, vol) in enumerate(price_history) if i % 4 == 0]
            if len(higher_tf_prices) < 20:
                return 0.5

            higher_tf_prices = higher_tf_prices[-50:]  # Last 50 points for higher TF

            # Calculate EMAs for both timeframes
            lower_tf_ema = TechnicalIndicators.calculate_ema(
                [p for ts, p, vol in price_history[-50:]], self.config["lower_tf_ema_period"]
            )
            higher_tf_ema = TechnicalIndicators.calculate_ema(
                higher_tf_prices, self.config["higher_tf_ema_period"]
            )

            if not lower_tf_ema or not higher_tf_ema:
                return 0.5

            # Get latest EMA values
            latest_lower_ema = lower_tf_ema[-1] if lower_tf_ema else 0
            latest_higher_ema = higher_tf_ema[-1] if higher_tf_ema else 0

            # Get current price
            current_price = price_history[-1][1] if price_history else 0

            if current_price == 0:
                return 0.5

            # Calculate trend directions
            lower_tf_trend = 1 if current_price > latest_lower_ema else -1
            higher_tf_trend = 1 if current_price > latest_higher_ema else -1

            # Perfect alignment = 1.0, opposite = 0.0
            alignment = 1.0 if lower_tf_trend == higher_tf_trend else 0.0

            # Weight the alignment
            weighted_alignment = (
                alignment * self.config["higher_tf_weight"] +
                alignment * self.config["lower_tf_weight"]
            )

            return max(0.0, min(1.0, weighted_alignment))

        except Exception as e:
            logger.warning(f"Multi-timeframe analysis error for {symbol}: {e}")
            return 0.5  # Neutral on error


class VolatilityFilter:
    """Volatility-based signal filtering"""

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or {
            "atr_period": 14,
            "min_volatility_threshold": 0.005,   # 0.5% minimum volatility
            "max_volatility_threshold": 0.05,    # 5% maximum volatility (too noisy)
            "volatility_lookback": 20,           # Periods to look back for volatility
            "high_volatility_penalty": 0.3,      # Reduce signal strength in high vol
            "low_volatility_boost": 1.2,         # Boost signal strength in low vol
        }

    def calculate_atr(self, highs: List[float], lows: List[float], closes: List[float], period: int = 14) -> List[float]:
        """Calculate Average True Range"""
        if len(highs) != len(lows) or len(lows) != len(closes):
            return []

        atr_values = []
        for i in range(len(closes)):
            if i < period - 1:
                atr_values.append(0.0)
                continue

            # True Range calculation
            tr1 = highs[i] - lows[i]
            tr2 = abs(highs[i] - closes[i-1]) if i > 0 else tr1
            tr3 = abs(lows[i] - closes[i-1]) if i > 0 else tr1

            true_range = max(tr1, tr2, tr3)

            if i == period - 1:
                # First ATR is simple average
                atr_values.append(sum([
                    max(highs[j] - lows[j],
                        abs(highs[j] - closes[j-1]) if j > 0 else highs[j] - lows[j],
                        abs(lows[j] - closes[j-1]) if j > 0 else highs[j] - lows[j])
                    for j in range(period)
                ]) / period)
            else:
                # Smoothed ATR
                prev_atr = atr_values[-1]
                atr_values.append((prev_atr * (period - 1) + true_range) / period)

        return atr_values

    def analyze_market_volatility(self, symbol: str, strategy_instance) -> Dict[str, Any]:
        """Analyze current market volatility conditions"""
        try:
            price_history = strategy_instance.price_history.get(symbol, [])
            if len(price_history) < self.config["volatility_lookback"] + 10:
                return {
                    "volatility_level": "insufficient_data",
                    "atr_value": 0.0,
                    "volatility_percent": 0.0,
                    "signal_multiplier": 1.0,
                    "filter_passed": True
                }

            # Extract OHLC data
            closes = [price for ts, price, vol in price_history]
            highs = []
            lows = []

            # Estimate highs/lows from price history (simplified)
            for i, (ts, price, vol) in enumerate(price_history):
                # Use neighboring prices to estimate HL
                if i > 0 and i < len(price_history) - 1:
                    prev_price = price_history[i-1][1]
                    next_price = price_history[i+1][1]
                    high = max(price, prev_price, next_price) * 1.002  # Add small buffer
                    low = min(price, prev_price, next_price) * 0.998
                else:
                    high = price * 1.002
                    low = price * 0.998

                highs.append(high)
                lows.append(low)

            # Calculate ATR
            atr_values = self.calculate_atr(highs, lows, closes, self.config["atr_period"])
            current_atr = atr_values[-1] if atr_values else 0.0

            # Calculate volatility as percentage
            current_price = closes[-1]
            volatility_percent = (current_atr / current_price) if current_price > 0 else 0.0

            # Determine volatility level
            if volatility_percent < self.config["min_volatility_threshold"]:
                volatility_level = "low"
                signal_multiplier = self.config["low_volatility_boost"]
            elif volatility_percent > self.config["max_volatility_threshold"]:
                volatility_level = "high"
                signal_multiplier = self.config["high_volatility_penalty"]
            else:
                volatility_level = "normal"
                signal_multiplier = 1.0

            # Determine if signal should pass filter
            filter_passed = (
                self.config["min_volatility_threshold"] <= volatility_percent <= self.config["max_volatility_threshold"]
            )

            return {
                "volatility_level": volatility_level,
                "atr_value": current_atr,
                "volatility_percent": volatility_percent,
                "signal_multiplier": signal_multiplier,
                "filter_passed": filter_passed
            }

        except Exception as e:
            logger.warning(f"Volatility analysis error for {symbol}: {e}")
            return {
                "volatility_level": "error",
                "atr_value": 0.0,
                "volatility_percent": 0.0,
                "signal_multiplier": 1.0,
                "filter_passed": True  # Allow signals if analysis fails
            }


class ScalpingStrategy:
    """
    Enhanced Scalping Strategy with Multi-Timeframe Confirmation and Volatility Filtering
    ULTRA SFL implementation with enterprise-grade signal generation
    """

    def __init__(self, risk_manager=None, config: Optional[Dict[str, Any]] = None):
        self.name = "ScalpingStrategy"

        # Default configuration
        self.config = {
            "ema_short_period": 5,
            "ema_medium_period": 20,
            "ema_long_period": 50,
            "rsi_period": 14,
            "rsi_overbought": 70,
            "rsi_oversold": 30,
            "min_signal_strength": 0.6,
            "max_hold_time_minutes": 15,
            "profit_target_percent": 0.2,  # 0.2%
            "stop_loss_percent": 0.1,      # 0.1%
            "min_price_history": 100,
            "enable_multi_timeframe": True,
            "enable_volatility_filter": True,
            "min_trend_alignment": 0.6,   # Minimum MTF alignment score
            "volatility_filter_strict": False,  # If true, reject signals in bad volatility
        }

        self.risk_manager = risk_manager
        self.price_history: Dict[str, List[Tuple[float, float, float]]] = {}  # symbol -> [(timestamp, price, volume), ...]
        self.active_positions: Dict[str, Dict[str, Any]] = {}

        # Enhanced components
        self.mtf_confirmation = MultiTimeframeConfirmation()
        self.volatility_filter = VolatilityFilter()

        if config:
            self.config.update(config)
            "stop_loss_percent": 0.5,  # 0.5%
            "trend_confirmation": True,
            "volume_confirmation": True,
            "min_price_history": 100,  # Minimum historical prices needed
        }

        # Update with provided config
        if config:
            self.config.update(config)

        # Risk manager integration
        self.risk_manager = risk_manager

        # Price history for indicator calculations
        self.price_history: Dict[
            str, List[Tuple[float, float]]
        ] = {}  # symbol -> [(timestamp, price), ...]

        # Active positions tracking
        self.active_positions: Dict[str, Dict[str, Any]] = {}

        logger.info(f"ðŸš€ ScalpingStrategy initialized with config: {self.config}")

    def add_price_data(
        self,
        symbol: str,
        price: float,
        volume: float = 0.0,
        timestamp: Optional[float] = None,
    ):
        """
        Add price data point for indicator calculations
        """
        if timestamp is None:
            timestamp = time.time()

        if symbol not in self.price_history:
            self.price_history[symbol] = []

        # Keep only recent data (last 24 hours for scalping)
        cutoff_time = timestamp - (24 * 60 * 60)  # 24 hours ago
        self.price_history[symbol] = [
            (ts, p) for ts, p in self.price_history[symbol] if ts > cutoff_time
        ]

        # Add new data point
        self.price_history[symbol].append((timestamp, price))

        # Limit history size to prevent memory issues
        max_history = 1000
        if len(self.price_history[symbol]) > max_history:
            self.price_history[symbol] = self.price_history[symbol][-max_history:]

    def _get_price_series(
        self, symbol: str, max_points: Optional[int] = None
    ) -> List[float]:
        """Get price series for a symbol"""
        if symbol not in self.price_history:
            return []

        prices = [price for _, price in self.price_history[symbol]]
        if max_points and len(prices) > max_points:
            prices = prices[-max_points:]

        return prices

    def _calculate_indicators(self, symbol: str) -> Dict[str, Any]:
        """
        Calculate all technical indicators for a symbol
        Uses Rust acceleration when available
        """
        start_time = time.time()

        prices = self._get_price_series(symbol, self.config["min_price_history"])
        if len(prices) < self.config["min_price_history"]:
            return {}

        # Calculate EMAs (5, 20, 50)
        ema_5_values = TechnicalIndicators.calculate_ema(
            prices, self.config["ema_short_period"]
        )
        ema_20_values = TechnicalIndicators.calculate_ema(
            prices, self.config["ema_medium_period"]
        )
        ema_50_values = TechnicalIndicators.calculate_ema(
            prices, self.config["ema_long_period"]
        )

        # Calculate RSI
        rsi_values = TechnicalIndicators.calculate_rsi(
            prices, self.config["rsi_period"]
        )

        # Calculate SMAs for trend confirmation
        sma_5_values = TechnicalIndicators.calculate_sma(
            prices, self.config["ema_short_period"]
        )
        sma_20_values = TechnicalIndicators.calculate_sma(
            prices, self.config["ema_medium_period"]
        )

        # Calculate MACD
        macd_line, signal_line, histogram = TechnicalIndicators.calculate_macd(
            prices, 12, 26, 9
        )

        # Calculate Bollinger Bands
        bb_upper, bb_middle, bb_lower = TechnicalIndicators.calculate_bollinger_bands(
            prices, 20, 2.0
        )

        indicators = {
            # EMAs
            "ema_5": ema_5_values[-1] if ema_5_values else None,
            "ema_20": ema_20_values[-1] if ema_20_values else None,
            "ema_50": ema_50_values[-1] if ema_50_values else None,
            # RSI
            "rsi_14": rsi_values[-1] if rsi_values else None,
            # SMAs
            "sma_5": sma_5_values[-1] if sma_5_values else None,
            "sma_20": sma_20_values[-1] if sma_20_values else None,
            # MACD
            "macd_line": macd_line[-1] if macd_line else None,
            "macd_signal": signal_line[-1] if signal_line else None,
            "macd_histogram": histogram[-1] if histogram else None,
            # Bollinger Bands
            "bb_upper": bb_upper[-1] if bb_upper else None,
            "bb_middle": bb_middle[-1] if bb_middle else None,
            "bb_lower": bb_lower[-1] if bb_lower else None,
            # Price data
            "current_price": prices[-1],
            "price_change_5m": self._calculate_price_change(
                symbol, 5 * 60
            ),  # 5 minutes
            "price_change_15m": self._calculate_price_change(
                symbol, 15 * 60
            ),  # 15 minutes
            "volatility_5m": self._calculate_volatility(symbol, 5 * 60),
            # Metadata
            "price_history_count": len(prices),
            "timestamp": time.time(),
        }

        STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
        return indicators

    def _calculate_price_change(self, symbol: str, seconds_back: int) -> float:
        """Calculate price change over the last N seconds"""
        if symbol not in self.price_history:
            return 0.0

        current_time = time.time()
        cutoff_time = current_time - seconds_back

        # Find prices within the time window
        recent_prices = [
            price for ts, price in self.price_history[symbol] if ts >= cutoff_time
        ]

        if len(recent_prices) < 2:
            return 0.0

        return ((recent_prices[-1] - recent_prices[0]) / recent_prices[0]) * 100

    def _calculate_volatility(self, symbol: str, seconds_back: int) -> float:
        """Calculate price volatility over the last N seconds"""
        if symbol not in self.price_history:
            return 0.0

        current_time = time.time()
        cutoff_time = current_time - seconds_back

        # Find prices within the time window
        recent_prices = [
            price for ts, price in self.price_history[symbol] if ts >= cutoff_time
        ]

        if len(recent_prices) < 5:  # Need minimum data points
            return 0.0

        # Calculate returns
        returns = []
        for i in range(1, len(recent_prices)):
            ret = (recent_prices[i] - recent_prices[i - 1]) / recent_prices[i - 1]
            returns.append(ret)

        if not returns:
            return 0.0

        # Return standard deviation of returns as volatility measure
        return statistics.stdev(returns) * 100  # As percentage

    def _generate_buy_signal(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """
        Generate BUY signal based on EMA crossover and RSI confirmation
        """
        ema_5 = indicators.get("ema_5")
        ema_20 = indicators.get("ema_20")
        ema_50 = indicators.get("ema_50")
        rsi = indicators.get("rsi_14")
        current_price = indicators.get("current_price")

        if not all([ema_5, ema_20, ema_50, rsi, current_price]):
            return None

        confidence = 0.0
        reasons = []

        # EMA Bullish Crossover: EMA5 > EMA20 > EMA50
        if ema_5 > ema_20 > ema_50:
            confidence += 0.4
            reasons.append(
                f"EMA bullish alignment: 5({ema_5:.4f}) > 20({ema_20:.4f}) > 50({ema_50:.4f})"
            )
        elif ema_5 > ema_20:
            confidence += 0.2
            reasons.append(f"EMA short-term bullish: 5({ema_5:.4f}) > 20({ema_20:.4f})")

        # RSI Oversold Confirmation
        if rsi < self.config["rsi_oversold"]:
            confidence += 0.3
            reasons.append(f"RSI oversold: {rsi:.1f} < {self.config['rsi_oversold']}")
        elif rsi < 50:
            confidence += 0.1
            reasons.append(f"RSI neutral-bullish: {rsi:.1f} < 50")

        # Price momentum confirmation
        price_change_5m = indicators.get("price_change_5m", 0)
        if price_change_5m > 0.05:  # 0.05% upward momentum
            confidence += 0.1
            reasons.append(f"Positive momentum: +{price_change_5m:.3f}% in 5m")

        # Trend confirmation
        if self.config["trend_confirmation"]:
            ema_20_prev = self._get_previous_indicator(symbol, "ema_20", 1)
            if ema_20_prev and ema_20 > ema_20_prev:
                confidence += 0.1
                reasons.append("EMA trend strengthening")

        # Minimum confidence check
        if confidence < self.config["min_signal_strength"]:
            return None

        # Calculate position sizing
        stop_loss = current_price * (1 - self.config["stop_loss_percent"] / 100)
        take_profit = current_price * (1 + self.config["profit_target_percent"] / 100)

        # Risk-adjusted position size
        if self.risk_manager:
            risk_assessment = self.risk_manager.evaluate_trade(
                symbol, current_price * 0.01, 1.0
            )  # Test with small position
            if not risk_assessment.approved:
                logger.warning(
                    f"Risk check failed for {symbol} BUY signal: {risk_assessment.reasoning}"
                )
                return None

            # Adjust position size based on risk limits
            max_position_value = risk_assessment.adjusted_position_size or (
                self.risk_manager.portfolio.total_value * 0.01
            )  # 1% of portfolio
            quantity = max_position_value / current_price
        else:
            # Default position size: 0.5% of portfolio (assuming $10k portfolio)
            quantity = (10000 * 0.005) / current_price

        signal = TradingSignal(
            symbol=symbol,
            signal_type=SignalType.BUY,
            confidence=min(confidence, 1.0),
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            quantity=quantity,
            reasoning=" | ".join(reasons),
            indicators=indicators,
        )

        return signal

    def _generate_sell_signal(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """
        Generate SELL signal based on EMA crossover and RSI confirmation
        """
        ema_5 = indicators.get("ema_5")
        ema_20 = indicators.get("ema_20")
        ema_50 = indicators.get("ema_50")
        rsi = indicators.get("rsi_14")
        current_price = indicators.get("current_price")

        if not all([ema_5, ema_20, ema_50, rsi, current_price]):
            return None

        confidence = 0.0
        reasons = []

        # EMA Bearish Crossover: EMA5 < EMA20 < EMA50
        if ema_5 < ema_20 < ema_50:
            confidence += 0.4
            reasons.append(
                f"EMA bearish alignment: 5({ema_5:.4f}) < 20({ema_20:.4f}) < 50({ema_50:.4f})"
            )
        elif ema_5 < ema_20:
            confidence += 0.2
            reasons.append(f"EMA short-term bearish: 5({ema_5:.4f}) < 20({ema_20:.4f})")

        # RSI Overbought Confirmation
        if rsi > self.config["rsi_overbought"]:
            confidence += 0.3
            reasons.append(
                f"RSI overbought: {rsi:.1f} > {self.config['rsi_overbought']}"
            )
        elif rsi > 50:
            confidence += 0.1
            reasons.append(f"RSI neutral-bearish: {rsi:.1f} > 50")

        # Price momentum confirmation
        price_change_5m = indicators.get("price_change_5m", 0)
        if price_change_5m < -0.05:  # 0.05% downward momentum
            confidence += 0.1
            reasons.append(f"Negative momentum: {price_change_5m:.3f}% in 5m")

        # Trend confirmation
        if self.config["trend_confirmation"]:
            ema_20_prev = self._get_previous_indicator(symbol, "ema_20", 1)
            if ema_20_prev and ema_20 < ema_20_prev:
                confidence += 0.1
                reasons.append("EMA trend weakening")

        # Minimum confidence check
        if confidence < self.config["min_signal_strength"]:
            return None

        # Calculate position sizing
        stop_loss = current_price * (1 + self.config["stop_loss_percent"] / 100)
        take_profit = current_price * (1 - self.config["profit_target_percent"] / 100)

        # Risk-adjusted position size
        if self.risk_manager:
            risk_assessment = self.risk_manager.evaluate_trade(
                symbol, current_price * 0.01, 1.0
            )  # Test with small position
            if not risk_assessment.approved:
                logger.warning(
                    f"Risk check failed for {symbol} SELL signal: {risk_assessment.reasoning}"
                )
                return None

            # Adjust position size based on risk limits
            max_position_value = risk_assessment.adjusted_position_size or (
                self.risk_manager.portfolio.total_value * 0.005
            )  # 0.5% of portfolio
            quantity = max_position_value / current_price
        else:
            # Default position size: 0.5% of portfolio (assuming $10k portfolio)
            quantity = (10000 * 0.005) / current_price

        signal = TradingSignal(
            symbol=symbol,
            signal_type=SignalType.SELL,
            confidence=min(confidence, 1.0),
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            quantity=quantity,
            reasoning=" | ".join(reasons),
            indicators=indicators,
        )

        return signal

    def _generate_exit_signal(
        self, symbol: str, indicators: Dict[str, Any]
    ) -> Optional[TradingSignal]:
        """
        Generate exit signal for existing positions
        """
        if symbol not in self.active_positions:
            return None

        position = self.active_positions[symbol]
        current_price = indicators.get("current_price")
        rsi = indicators.get("rsi_14")

        if not current_price:
            return None

        position_type = position["signal_type"]
        entry_price = position["entry_price"]
        stop_loss = position["stop_loss"]
        take_profit = position["take_profit"]
        entry_time = position["timestamp"]

        # Check time-based exit
        hold_time_minutes = (time.time() - entry_time) / 60
        if hold_time_minutes >= self.config["max_hold_time_minutes"]:
            return TradingSignal(
                symbol=symbol,
                signal_type=SignalType.CLOSE_LONG
                if position_type == SignalType.BUY
                else SignalType.CLOSE_SHORT,
                confidence=0.8,
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                quantity=position["quantity"],
                reasoning=f"Max hold time exceeded: {hold_time_minutes:.1f}min > {self.config['max_hold_time_minutes']}min",
                indicators=indicators,
            )

        # Check stop loss / take profit
        if position_type == SignalType.BUY:
            if current_price <= stop_loss:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position["quantity"],
                    reasoning=f"Stop loss hit: {current_price:.4f} <= {stop_loss:.4f}",
                    indicators=indicators,
                )
            elif current_price >= take_profit:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position["quantity"],
                    reasoning=f"Take profit hit: {current_price:.4f} >= {take_profit:.4f}",
                    indicators=indicators,
                )
        else:  # SELL position
            if current_price >= stop_loss:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_SHORT,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position["quantity"],
                    reasoning=f"Stop loss hit: {current_price:.4f} >= {stop_loss:.4f}",
                    indicators=indicators,
                )
            elif current_price <= take_profit:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_SHORT,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position["quantity"],
                    reasoning=f"Take profit hit: {current_price:.4f} <= {take_profit:.4f}",
                    indicators=indicators,
                )

        # Check RSI reversal signals
        if rsi:
            if position_type == SignalType.BUY and rsi > self.config["rsi_overbought"]:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.7,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position["quantity"],
                    reasoning=f"RSI overbought exit: {rsi:.1f} > {self.config['rsi_overbought']}",
                    indicators=indicators,
                )
            elif position_type == SignalType.SELL and rsi < self.config["rsi_oversold"]:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_SHORT,
                    confidence=0.7,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position["quantity"],
                    reasoning=f"RSI oversold exit: {rsi:.1f} < {self.config['rsi_oversold']}",
                    indicators=indicators,
                )

        return None

    def _get_previous_indicator(
        self, symbol: str, indicator_name: str, periods_back: int
    ) -> Optional[float]:
        """Get previous indicator value for trend analysis"""
        # This is a simplified implementation - in production you'd store indicator history
        return None

    def generate_signal(
        self, symbol: str, market_data: MarketData
    ) -> Optional[TradingSignal]:
        """
        Enhanced signal generation with multi-timeframe confirmation and volatility filtering
        """
        start_time = time.time()

        # Add price data to history
        self.add_price_data(
            symbol, market_data.price, market_data.volume, market_data.timestamp
        )

        # Calculate base indicators
        indicators = self._calculate_indicators(symbol)
        if not indicators:
            return None

        # Apply multi-timeframe confirmation if enabled
        trend_alignment_score = 1.0
        if self.config.get("enable_multi_timeframe", True):
            trend_alignment_score = self.mtf_confirmation.analyze_trend_alignment(symbol, self)
            if trend_alignment_score < self.config.get("min_trend_alignment", 0.6):
                logger.debug(f"MTF alignment too low for {symbol}: {trend_alignment_score:.2f}")
                STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
                return None

        # Apply volatility filtering if enabled
        volatility_analysis = {"filter_passed": True, "signal_multiplier": 1.0}
        if self.config.get("enable_volatility_filter", True):
            volatility_analysis = self.volatility_filter.analyze_market_volatility(symbol, self)

            # Check if signal should be filtered out
            if self.config.get("volatility_filter_strict", False) and not volatility_analysis["filter_passed"]:
                logger.debug(f"Volatility filter rejected signal for {symbol}: {volatility_analysis}")
                STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
                return None

        # Check for exit signals first (if we have a position)
        exit_signal = self._generate_exit_signal(symbol, indicators)
        if exit_signal:
            # Apply volatility multiplier to exit signal confidence
            exit_signal.confidence *= volatility_analysis["signal_multiplier"]
            SIGNALS_GENERATED.labels(
                strategy=self.name, signal_type=exit_signal.signal_type.value
            ).inc()
            SIGNAL_CONFIDENCE.labels(strategy=self.name).observe(exit_signal.confidence)

            # Add enhanced metadata
            exit_signal.metadata = {
                "trend_alignment": trend_alignment_score,
                "volatility_level": volatility_analysis.get("volatility_level", "unknown"),
                "volatility_multiplier": volatility_analysis["signal_multiplier"],
                "mtf_enabled": self.config.get("enable_multi_timeframe", True),
                "volatility_filter_enabled": self.config.get("enable_volatility_filter", True),
            }
            return exit_signal

        # Check for entry signals
        buy_signal = self._generate_buy_signal(symbol, indicators)
        sell_signal = self._generate_sell_signal(symbol, indicators)

        # Apply trend alignment and volatility filtering to entry signals
        if buy_signal:
            buy_signal.confidence *= trend_alignment_score * volatility_analysis["signal_multiplier"]
            buy_signal.metadata = {
                "trend_alignment": trend_alignment_score,
                "volatility_level": volatility_analysis.get("volatility_level", "unknown"),
                "volatility_multiplier": volatility_analysis["signal_multiplier"],
                "mtf_enabled": self.config.get("enable_multi_timeframe", True),
                "volatility_filter_enabled": self.config.get("enable_volatility_filter", True),
            }

        if sell_signal:
            sell_signal.confidence *= trend_alignment_score * volatility_analysis["signal_multiplier"]
            sell_signal.metadata = {
                "trend_alignment": trend_alignment_score,
                "volatility_level": volatility_analysis.get("volatility_level", "unknown"),
                "volatility_multiplier": volatility_analysis["signal_multiplier"],
                "mtf_enabled": self.config.get("enable_multi_timeframe", True),
                "volatility_filter_enabled": self.config.get("enable_volatility_filter", True),
            }

        # Choose the stronger signal after filtering
        if buy_signal and sell_signal:
            if buy_signal.confidence > sell_signal.confidence:
                signal = buy_signal
            else:
                signal = sell_signal
        elif buy_signal:
            signal = buy_signal
        elif sell_signal:
            signal = sell_signal
        else:
            signal = None

        if signal:
            # Final confidence check
            if signal.confidence < self.config.get("min_signal_strength", 0.6):
                logger.debug(f"Signal confidence too low for {symbol}: {signal.confidence:.2f}")
                STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
                return None

            SIGNALS_GENERATED.labels(
                strategy=self.name, signal_type=signal.signal_type.value
            ).inc()
            SIGNAL_CONFIDENCE.labels(strategy=self.name).observe(signal.confidence)

            # Track active position
            if signal.signal_type in [SignalType.BUY, SignalType.SELL]:
                self.active_positions[symbol] = {
                    "signal_type": signal.signal_type,
                    "entry_price": signal.entry_price,
                    "stop_loss": signal.stop_loss,
                    "take_profit": signal.take_profit,
                    "quantity": signal.quantity,
                    "timestamp": signal.timestamp,
                    "indicators": signal.indicators,
                    "trend_alignment": trend_alignment_score,
                    "volatility_analysis": volatility_analysis,
                }

        STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
        return signal

    def get_strategy_status(self) -> Dict[str, Any]:
        """
        Get strategy status for monitoring
        """
        return {
            "name": self.name,
            "active_positions": len(self.active_positions),
            "symbols_tracked": len(self.price_history),
            "total_price_points": sum(
                len(history) for history in self.price_history.values()
            ),
            "config": self.config,
            "positions": self.active_positions,
        }
