# python/supreme_system_v5/strategies.py
"""
Trading Strategies - Scalping strategy with EMA and RSI indicators
ULTRA SFL implementation with enterprise-grade signal generation
"""

import time
import statistics
from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum

import numpy as np
from loguru import logger
from prometheus_client import Counter, Gauge, Histogram

# Metrics
SIGNALS_GENERATED = Counter('strategy_signals_total', 'Signals generated by strategy', ['strategy', 'signal_type'])
SIGNAL_CONFIDENCE = Histogram('strategy_signal_confidence', 'Signal confidence distribution', ['strategy'])
STRATEGY_LATENCY = Histogram('strategy_latency_seconds', 'Strategy calculation latency', ['strategy'])

class SignalType(Enum):
    """Trading signal types"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"

@dataclass
class TradingSignal:
    """Trading signal with comprehensive metadata"""

    symbol: str
    signal_type: SignalType
    confidence: float  # 0.0 to 1.0
    entry_price: float
    stop_loss: float
    take_profit: float
    quantity: float
    reasoning: str
    indicators: Dict[str, Any] = field(default_factory=dict)
    timestamp: float = field(default_factory=time.time)

    def __post_init__(self):
        """Validate signal parameters"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")

        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive, got {self.quantity}")

@dataclass
class MarketData:
    """Market data structure for strategy calculations"""

    symbol: str
    price: float
    volume: float
    timestamp: float
    bid: Optional[float] = None
    ask: Optional[float] = None
    high_24h: Optional[float] = None
    low_24h: Optional[float] = None

class TechnicalIndicators:
    """Technical indicator calculations with Rust acceleration"""

    @staticmethod
    def calculate_ema(prices: List[float], period: int) -> List[float]:
        """
        Calculate Exponential Moving Average
        Uses Rust implementation for maximum performance
        """
        if len(prices) < period:
            return []

        try:
            # Try Rust implementation first
            import supreme_engine_rs
            import numpy as np

            price_array = np.array(prices, dtype=np.float64)
            result = supreme_engine_rs.fast_ema(price_array, period)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust EMA not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_ema_python(prices, period)

    @staticmethod
    def _calculate_ema_python(prices: List[float], period: int) -> List[float]:
        """Python fallback for EMA calculation"""
        if len(prices) < period:
            return []

        multiplier = 2.0 / (period + 1)
        ema_values = []

        # First EMA is SMA
        sma = sum(prices[:period]) / period
        ema_values.append(sma)

        # Calculate subsequent EMAs
        for price in prices[period:]:
            ema = (price * multiplier) + (ema_values[-1] * (1 - multiplier))
            ema_values.append(ema)

        return ema_values

    @staticmethod
    def calculate_rsi(prices: List[float], period: int = 14) -> List[float]:
        """
        Calculate Relative Strength Index
        Uses Rust implementation for maximum performance
        """
        if len(prices) < period + 1:
            return []

        try:
            # Try Rust implementation first
            import supreme_engine_rs
            import numpy as np

            price_array = np.array(prices, dtype=np.float64)
            result = supreme_engine_rs.fast_rsi(price_array, period)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust RSI not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_rsi_python(prices, period)

    @staticmethod
    def _calculate_rsi_python(prices: List[float], period: int = 14) -> List[float]:
        """Python fallback for RSI calculation"""
        if len(prices) < period + 1:
            return []

        rsi_values = []
        gains = []
        losses = []

        # Calculate price changes
        for i in range(1, len(prices)):
            change = prices[i] - prices[i-1]
            gains.append(max(change, 0))
            losses.append(max(-change, 0))

        # Calculate initial averages
        avg_gain = sum(gains[:period]) / period
        avg_loss = sum(losses[:period]) / period

        # Calculate first RSI
        if avg_loss == 0:
            rsi = 100.0
        else:
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
        rsi_values.append(rsi)

        # Calculate subsequent RSIs using Wilder's smoothing
        for i in range(period, len(gains)):
            gain = gains[i]
            loss = losses[i]

            avg_gain = ((avg_gain * (period - 1)) + gain) / period
            avg_loss = ((avg_loss * (period - 1)) + loss) / period

            if avg_loss == 0:
                rsi = 100.0
            else:
                rs = avg_gain / avg_loss
                rsi = 100 - (100 / (1 + rs))

            rsi_values.append(rsi)

        return rsi_values

    @staticmethod
    def calculate_sma(prices: List[float], period: int) -> List[float]:
        """Calculate Simple Moving Average"""
        if len(prices) < period:
            return []

        try:
            # Try Rust implementation first
            import supreme_engine_rs
            import numpy as np

            price_array = np.array(prices, dtype=np.float64)
            result = supreme_engine_rs.fast_sma(price_array, period)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust SMA not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_sma_python(prices, period)

    @staticmethod
    def _calculate_sma_python(prices: List[float], period: int) -> List[float]:
        """Python fallback for SMA calculation"""
        if len(prices) < period:
            return []

        sma_values = []
        for i in range(period - 1, len(prices)):
            sma = sum(prices[i-period+1:i+1]) / period
            sma_values.append(sma)

        return sma_values

    @staticmethod
    def calculate_macd(prices: List[float], fast_period: int = 12, slow_period: int = 26, signal_period: int = 9) -> Tuple[List[float], List[float], List[float]]:
        """Calculate MACD with signal line and histogram"""
        try:
            # Try Rust implementation first
            import supreme_engine_rs
            import numpy as np

            price_array = np.array(prices, dtype=np.float64)
            macd_line, signal_line, histogram = supreme_engine_rs.fast_macd(price_array, fast_period, slow_period, signal_period)
            return macd_line.tolist(), signal_line.tolist(), histogram.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust MACD not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_macd_python(prices, fast_period, slow_period, signal_period)

    @staticmethod
    def _calculate_macd_python(prices: List[float], fast_period: int = 12, slow_period: int = 26, signal_period: int = 9) -> Tuple[List[float], List[float], List[float]]:
        """Python fallback for MACD calculation"""
        if len(prices) < slow_period:
            return [], [], []

        # Calculate EMAs
        fast_ema = TechnicalIndicators.calculate_ema(prices, fast_period)
        slow_ema = TechnicalIndicators.calculate_ema(prices, slow_period)

        # Calculate MACD line
        macd_line = []
        for i in range(len(slow_ema)):
            fast_idx = i + (slow_period - fast_period)
            if fast_idx < len(fast_ema):
                macd_line.append(fast_ema[fast_idx] - slow_ema[i])

        # Calculate signal line
        signal_line = TechnicalIndicators.calculate_ema(macd_line, signal_period)

        # Calculate histogram
        histogram = []
        for i in range(len(signal_line)):
            macd_idx = i + (signal_period - 1)
            if macd_idx < len(macd_line):
                histogram.append(macd_line[macd_idx] - signal_line[i])

        return macd_line, signal_line, histogram

    @staticmethod
    def calculate_bollinger_bands(prices: List[float], period: int = 20, std_dev: float = 2.0) -> Tuple[List[float], List[float], List[float]]:
        """Calculate Bollinger Bands"""
        try:
            # Try Rust implementation first
            import supreme_engine_rs
            import numpy as np

            price_array = np.array(prices, dtype=np.float64)
            upper_band, middle_band, lower_band = supreme_engine_rs.bollinger_bands(price_array, period, std_dev)
            return upper_band.tolist(), middle_band.tolist(), lower_band.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust Bollinger Bands not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_bollinger_bands_python(prices, period, std_dev)

    @staticmethod
    def _calculate_bollinger_bands_python(prices: List[float], period: int = 20, std_dev: float = 2.0) -> Tuple[List[float], List[float], List[float]]:
        """Python fallback for Bollinger Bands calculation"""
        if len(prices) < period:
            return [], [], []

        sma_values = TechnicalIndicators.calculate_sma(prices, period)
        upper_band = []
        lower_band = []

        for i, sma in enumerate(sma_values):
            start_idx = i
            end_idx = i + period

            # Calculate standard deviation
            values = prices[start_idx:end_idx]
            variance = sum((x - sma) ** 2 for x in values) / period
            std = variance ** 0.5

            upper_band.append(sma + std_dev * std)
            lower_band.append(sma - std_dev * std)

        return upper_band, sma_values, lower_band

    @staticmethod
    def calculate_vwap(high: List[float], low: List[float], close: List[float], volume: List[float]) -> List[float]:
        """Calculate Volume Weighted Average Price"""
        try:
            # Try Rust implementation first
            import supreme_engine_rs
            import numpy as np

            high_array = np.array(high, dtype=np.float64)
            low_array = np.array(low, dtype=np.float64)
            close_array = np.array(close, dtype=np.float64)
            volume_array = np.array(volume, dtype=np.float64)

            result = supreme_engine_rs.volume_weighted_average_price(high_array, low_array, close_array, volume_array)
            return result.tolist()

        except (ImportError, Exception) as e:
            logger.debug(f"Rust VWAP not available, using Python fallback: {e}")
            return TechnicalIndicators._calculate_vwap_python(high, low, close, volume)

    @staticmethod
    def _calculate_vwap_python(high: List[float], low: List[float], close: List[float], volume: List[float]) -> List[float]:
        """Python fallback for VWAP calculation"""
        if len(high) != len(low) or len(low) != len(close) or len(close) != len(volume):
            return []

        vwap_values = []
        cumulative_volume = 0.0
        cumulative_volume_price = 0.0

        for i in range(len(close)):
            typical_price = (high[i] + low[i] + close[i]) / 3.0
            volume_price = typical_price * volume[i]

            cumulative_volume += volume[i]
            cumulative_volume_price += volume_price

            if cumulative_volume > 0.0:
                vwap_values.append(cumulative_volume_price / cumulative_volume)
            else:
                vwap_values.append(typical_price)

        return vwap_values

class ScalpingStrategy:
    """
    Scalping strategy using EMA crossover and RSI confirmation
    ULTRA SFL implementation with enterprise-grade signal generation
    """

    def __init__(self, risk_manager=None, config: Optional[Dict[str, Any]] = None):
        self.name = "ScalpingStrategy"

        # Default configuration
        self.config = {
            'ema_short_period': 5,
            'ema_medium_period': 20,
            'ema_long_period': 50,
            'rsi_period': 14,
            'rsi_overbought': 70,
            'rsi_oversold': 30,
            'min_signal_strength': 0.6,
            'max_hold_time_minutes': 15,
            'profit_target_percent': 0.2,  # 0.2%
            'stop_loss_percent': 0.5,      # 0.5%
            'trend_confirmation': True,
            'volume_confirmation': True,
            'min_price_history': 100  # Minimum historical prices needed
        }

        # Update with provided config
        if config:
            self.config.update(config)

        # Risk manager integration
        self.risk_manager = risk_manager

        # Price history for indicator calculations
        self.price_history: Dict[str, List[Tuple[float, float]]] = {}  # symbol -> [(timestamp, price), ...]

        # Active positions tracking
        self.active_positions: Dict[str, Dict[str, Any]] = {}

        logger.info(f"🚀 ScalpingStrategy initialized with config: {self.config}")

    def add_price_data(self, symbol: str, price: float, volume: float = 0.0, timestamp: Optional[float] = None):
        """
        Add price data point for indicator calculations
        """
        if timestamp is None:
            timestamp = time.time()

        if symbol not in self.price_history:
            self.price_history[symbol] = []

        # Keep only recent data (last 24 hours for scalping)
        cutoff_time = timestamp - (24 * 60 * 60)  # 24 hours ago
        self.price_history[symbol] = [
            (ts, p) for ts, p in self.price_history[symbol]
            if ts > cutoff_time
        ]

        # Add new data point
        self.price_history[symbol].append((timestamp, price))

        # Limit history size to prevent memory issues
        max_history = 1000
        if len(self.price_history[symbol]) > max_history:
            self.price_history[symbol] = self.price_history[symbol][-max_history:]

    def _get_price_series(self, symbol: str, max_points: Optional[int] = None) -> List[float]:
        """Get price series for a symbol"""
        if symbol not in self.price_history:
            return []

        prices = [price for _, price in self.price_history[symbol]]
        if max_points and len(prices) > max_points:
            prices = prices[-max_points:]

        return prices

    def _calculate_indicators(self, symbol: str) -> Dict[str, Any]:
        """
        Calculate all technical indicators for a symbol
        Uses Rust acceleration when available
        """
        start_time = time.time()

        prices = self._get_price_series(symbol, self.config['min_price_history'])
        if len(prices) < self.config['min_price_history']:
            return {}

        # Calculate EMAs (5, 20, 50)
        ema_5_values = TechnicalIndicators.calculate_ema(prices, self.config['ema_short_period'])
        ema_20_values = TechnicalIndicators.calculate_ema(prices, self.config['ema_medium_period'])
        ema_50_values = TechnicalIndicators.calculate_ema(prices, self.config['ema_long_period'])

        # Calculate RSI
        rsi_values = TechnicalIndicators.calculate_rsi(prices, self.config['rsi_period'])

        # Calculate SMAs for trend confirmation
        sma_5_values = TechnicalIndicators.calculate_sma(prices, self.config['ema_short_period'])
        sma_20_values = TechnicalIndicators.calculate_sma(prices, self.config['ema_medium_period'])

        # Calculate MACD
        macd_line, signal_line, histogram = TechnicalIndicators.calculate_macd(prices, 12, 26, 9)

        # Calculate Bollinger Bands
        bb_upper, bb_middle, bb_lower = TechnicalIndicators.calculate_bollinger_bands(prices, 20, 2.0)

        indicators = {
            # EMAs
            'ema_5': ema_5_values[-1] if ema_5_values else None,
            'ema_20': ema_20_values[-1] if ema_20_values else None,
            'ema_50': ema_50_values[-1] if ema_50_values else None,

            # RSI
            'rsi_14': rsi_values[-1] if rsi_values else None,

            # SMAs
            'sma_5': sma_5_values[-1] if sma_5_values else None,
            'sma_20': sma_20_values[-1] if sma_20_values else None,

            # MACD
            'macd_line': macd_line[-1] if macd_line else None,
            'macd_signal': signal_line[-1] if signal_line else None,
            'macd_histogram': histogram[-1] if histogram else None,

            # Bollinger Bands
            'bb_upper': bb_upper[-1] if bb_upper else None,
            'bb_middle': bb_middle[-1] if bb_middle else None,
            'bb_lower': bb_lower[-1] if bb_lower else None,

            # Price data
            'current_price': prices[-1],
            'price_change_5m': self._calculate_price_change(symbol, 5 * 60),  # 5 minutes
            'price_change_15m': self._calculate_price_change(symbol, 15 * 60),  # 15 minutes
            'volatility_5m': self._calculate_volatility(symbol, 5 * 60),

            # Metadata
            'price_history_count': len(prices),
            'timestamp': time.time()
        }

        STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
        return indicators

    def _calculate_price_change(self, symbol: str, seconds_back: int) -> float:
        """Calculate price change over the last N seconds"""
        if symbol not in self.price_history:
            return 0.0

        current_time = time.time()
        cutoff_time = current_time - seconds_back

        # Find prices within the time window
        recent_prices = [
            price for ts, price in self.price_history[symbol]
            if ts >= cutoff_time
        ]

        if len(recent_prices) < 2:
            return 0.0

        return ((recent_prices[-1] - recent_prices[0]) / recent_prices[0]) * 100

    def _calculate_volatility(self, symbol: str, seconds_back: int) -> float:
        """Calculate price volatility over the last N seconds"""
        if symbol not in self.price_history:
            return 0.0

        current_time = time.time()
        cutoff_time = current_time - seconds_back

        # Find prices within the time window
        recent_prices = [
            price for ts, price in self.price_history[symbol]
            if ts >= cutoff_time
        ]

        if len(recent_prices) < 5:  # Need minimum data points
            return 0.0

        # Calculate returns
        returns = []
        for i in range(1, len(recent_prices)):
            ret = (recent_prices[i] - recent_prices[i-1]) / recent_prices[i-1]
            returns.append(ret)

        if not returns:
            return 0.0

        # Return standard deviation of returns as volatility measure
        return statistics.stdev(returns) * 100  # As percentage

    def _generate_buy_signal(self, symbol: str, indicators: Dict[str, Any]) -> Optional[TradingSignal]:
        """
        Generate BUY signal based on EMA crossover and RSI confirmation
        """
        ema_5 = indicators.get('ema_5')
        ema_20 = indicators.get('ema_20')
        ema_50 = indicators.get('ema_50')
        rsi = indicators.get('rsi_14')
        current_price = indicators.get('current_price')

        if not all([ema_5, ema_20, ema_50, rsi, current_price]):
            return None

        confidence = 0.0
        reasons = []

        # EMA Bullish Crossover: EMA5 > EMA20 > EMA50
        if ema_5 > ema_20 > ema_50:
            confidence += 0.4
            reasons.append(f"EMA bullish alignment: 5({ema_5:.4f}) > 20({ema_20:.4f}) > 50({ema_50:.4f})")
        elif ema_5 > ema_20:
            confidence += 0.2
            reasons.append(f"EMA short-term bullish: 5({ema_5:.4f}) > 20({ema_20:.4f})")

        # RSI Oversold Confirmation
        if rsi < self.config['rsi_oversold']:
            confidence += 0.3
            reasons.append(f"RSI oversold: {rsi:.1f} < {self.config['rsi_oversold']}")
        elif rsi < 50:
            confidence += 0.1
            reasons.append(f"RSI neutral-bullish: {rsi:.1f} < 50")

        # Price momentum confirmation
        price_change_5m = indicators.get('price_change_5m', 0)
        if price_change_5m > 0.05:  # 0.05% upward momentum
            confidence += 0.1
            reasons.append(f"Positive momentum: +{price_change_5m:.3f}% in 5m")

        # Trend confirmation
        if self.config['trend_confirmation']:
            ema_20_prev = self._get_previous_indicator(symbol, 'ema_20', 1)
            if ema_20_prev and ema_20 > ema_20_prev:
                confidence += 0.1
                reasons.append("EMA trend strengthening")

        # Minimum confidence check
        if confidence < self.config['min_signal_strength']:
            return None

        # Calculate position sizing
        stop_loss = current_price * (1 - self.config['stop_loss_percent'] / 100)
        take_profit = current_price * (1 + self.config['profit_target_percent'] / 100)

        # Risk-adjusted position size
        if self.risk_manager:
            risk_assessment = self.risk_manager.evaluate_trade(symbol, current_price * 0.01, 1.0)  # Test with small position
            if not risk_assessment.approved:
                logger.warning(f"Risk check failed for {symbol} BUY signal: {risk_assessment.reasoning}")
                return None

            # Adjust position size based on risk limits
            max_position_value = risk_assessment.adjusted_position_size or (self.risk_manager.portfolio.total_value * 0.01)  # 1% of portfolio
            quantity = max_position_value / current_price
        else:
            # Default position size: 0.5% of portfolio (assuming $10k portfolio)
            quantity = (10000 * 0.005) / current_price

        signal = TradingSignal(
            symbol=symbol,
            signal_type=SignalType.BUY,
            confidence=min(confidence, 1.0),
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            quantity=quantity,
            reasoning=" | ".join(reasons),
            indicators=indicators
        )

        return signal

    def _generate_sell_signal(self, symbol: str, indicators: Dict[str, Any]) -> Optional[TradingSignal]:
        """
        Generate SELL signal based on EMA crossover and RSI confirmation
        """
        ema_5 = indicators.get('ema_5')
        ema_20 = indicators.get('ema_20')
        ema_50 = indicators.get('ema_50')
        rsi = indicators.get('rsi_14')
        current_price = indicators.get('current_price')

        if not all([ema_5, ema_20, ema_50, rsi, current_price]):
            return None

        confidence = 0.0
        reasons = []

        # EMA Bearish Crossover: EMA5 < EMA20 < EMA50
        if ema_5 < ema_20 < ema_50:
            confidence += 0.4
            reasons.append(f"EMA bearish alignment: 5({ema_5:.4f}) < 20({ema_20:.4f}) < 50({ema_50:.4f})")
        elif ema_5 < ema_20:
            confidence += 0.2
            reasons.append(f"EMA short-term bearish: 5({ema_5:.4f}) < 20({ema_20:.4f})")

        # RSI Overbought Confirmation
        if rsi > self.config['rsi_overbought']:
            confidence += 0.3
            reasons.append(f"RSI overbought: {rsi:.1f} > {self.config['rsi_overbought']}")
        elif rsi > 50:
            confidence += 0.1
            reasons.append(f"RSI neutral-bearish: {rsi:.1f} > 50")

        # Price momentum confirmation
        price_change_5m = indicators.get('price_change_5m', 0)
        if price_change_5m < -0.05:  # 0.05% downward momentum
            confidence += 0.1
            reasons.append(f"Negative momentum: {price_change_5m:.3f}% in 5m")

        # Trend confirmation
        if self.config['trend_confirmation']:
            ema_20_prev = self._get_previous_indicator(symbol, 'ema_20', 1)
            if ema_20_prev and ema_20 < ema_20_prev:
                confidence += 0.1
                reasons.append("EMA trend weakening")

        # Minimum confidence check
        if confidence < self.config['min_signal_strength']:
            return None

        # Calculate position sizing
        stop_loss = current_price * (1 + self.config['stop_loss_percent'] / 100)
        take_profit = current_price * (1 - self.config['profit_target_percent'] / 100)

        # Risk-adjusted position size
        if self.risk_manager:
            risk_assessment = self.risk_manager.evaluate_trade(symbol, current_price * 0.01, 1.0)  # Test with small position
            if not risk_assessment.approved:
                logger.warning(f"Risk check failed for {symbol} SELL signal: {risk_assessment.reasoning}")
                return None

            # Adjust position size based on risk limits
            max_position_value = risk_assessment.adjusted_position_size or (self.risk_manager.portfolio.total_value * 0.005)  # 0.5% of portfolio
            quantity = max_position_value / current_price
        else:
            # Default position size: 0.5% of portfolio (assuming $10k portfolio)
            quantity = (10000 * 0.005) / current_price

        signal = TradingSignal(
            symbol=symbol,
            signal_type=SignalType.SELL,
            confidence=min(confidence, 1.0),
            entry_price=current_price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            quantity=quantity,
            reasoning=" | ".join(reasons),
            indicators=indicators
        )

        return signal

    def _generate_exit_signal(self, symbol: str, indicators: Dict[str, Any]) -> Optional[TradingSignal]:
        """
        Generate exit signal for existing positions
        """
        if symbol not in self.active_positions:
            return None

        position = self.active_positions[symbol]
        current_price = indicators.get('current_price')
        rsi = indicators.get('rsi_14')

        if not current_price:
            return None

        position_type = position['signal_type']
        entry_price = position['entry_price']
        stop_loss = position['stop_loss']
        take_profit = position['take_profit']
        entry_time = position['timestamp']

        # Check time-based exit
        hold_time_minutes = (time.time() - entry_time) / 60
        if hold_time_minutes >= self.config['max_hold_time_minutes']:
            return TradingSignal(
                symbol=symbol,
                signal_type=SignalType.CLOSE_LONG if position_type == SignalType.BUY else SignalType.CLOSE_SHORT,
                confidence=0.8,
                entry_price=current_price,
                stop_loss=stop_loss,
                take_profit=take_profit,
                quantity=position['quantity'],
                reasoning=f"Max hold time exceeded: {hold_time_minutes:.1f}min > {self.config['max_hold_time_minutes']}min",
                indicators=indicators
            )

        # Check stop loss / take profit
        if position_type == SignalType.BUY:
            if current_price <= stop_loss:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position['quantity'],
                    reasoning=f"Stop loss hit: {current_price:.4f} <= {stop_loss:.4f}",
                    indicators=indicators
                )
            elif current_price >= take_profit:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position['quantity'],
                    reasoning=f"Take profit hit: {current_price:.4f} >= {take_profit:.4f}",
                    indicators=indicators
                )
        else:  # SELL position
            if current_price >= stop_loss:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_SHORT,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position['quantity'],
                    reasoning=f"Stop loss hit: {current_price:.4f} >= {stop_loss:.4f}",
                    indicators=indicators
                )
            elif current_price <= take_profit:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_SHORT,
                    confidence=0.9,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position['quantity'],
                    reasoning=f"Take profit hit: {current_price:.4f} <= {take_profit:.4f}",
                    indicators=indicators
                )

        # Check RSI reversal signals
        if rsi:
            if position_type == SignalType.BUY and rsi > self.config['rsi_overbought']:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=0.7,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position['quantity'],
                    reasoning=f"RSI overbought exit: {rsi:.1f} > {self.config['rsi_overbought']}",
                    indicators=indicators
                )
            elif position_type == SignalType.SELL and rsi < self.config['rsi_oversold']:
                return TradingSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_SHORT,
                    confidence=0.7,
                    entry_price=current_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    quantity=position['quantity'],
                    reasoning=f"RSI oversold exit: {rsi:.1f} < {self.config['rsi_oversold']}",
                    indicators=indicators
                )

        return None

    def _get_previous_indicator(self, symbol: str, indicator_name: str, periods_back: int) -> Optional[float]:
        """Get previous indicator value for trend analysis"""
        # This is a simplified implementation - in production you'd store indicator history
        return None

    def generate_signal(self, symbol: str, market_data: MarketData) -> Optional[TradingSignal]:
        """
        Generate trading signal for a symbol based on market data
        """
        start_time = time.time()

        # Add price data to history
        self.add_price_data(symbol, market_data.price, market_data.volume, market_data.timestamp)

        # Calculate indicators
        indicators = self._calculate_indicators(symbol)
        if not indicators:
            return None

        # Check for exit signals first (if we have a position)
        exit_signal = self._generate_exit_signal(symbol, indicators)
        if exit_signal:
            SIGNALS_GENERATED.labels(strategy=self.name, signal_type=exit_signal.signal_type.value).inc()
            SIGNAL_CONFIDENCE.labels(strategy=self.name).observe(exit_signal.confidence)
            return exit_signal

        # Check for entry signals
        buy_signal = self._generate_buy_signal(symbol, indicators)
        sell_signal = self._generate_sell_signal(symbol, indicators)

        # Choose the stronger signal
        if buy_signal and sell_signal:
            if buy_signal.confidence > sell_signal.confidence:
                signal = buy_signal
            else:
                signal = sell_signal
        elif buy_signal:
            signal = buy_signal
        elif sell_signal:
            signal = sell_signal
        else:
            signal = None

        if signal:
            SIGNALS_GENERATED.labels(strategy=self.name, signal_type=signal.signal_type.value).inc()
            SIGNAL_CONFIDENCE.labels(strategy=self.name).observe(signal.confidence)

            # Track active position
            if signal.signal_type in [SignalType.BUY, SignalType.SELL]:
                self.active_positions[symbol] = {
                    'signal_type': signal.signal_type,
                    'entry_price': signal.entry_price,
                    'stop_loss': signal.stop_loss,
                    'take_profit': signal.take_profit,
                    'quantity': signal.quantity,
                    'timestamp': signal.timestamp,
                    'indicators': signal.indicators
                }

        STRATEGY_LATENCY.labels(strategy=self.name).observe(time.time() - start_time)
        return signal

    def get_strategy_status(self) -> Dict[str, Any]:
        """
        Get strategy status for monitoring
        """
        return {
            'name': self.name,
            'active_positions': len(self.active_positions),
            'symbols_tracked': len(self.price_history),
            'total_price_points': sum(len(history) for history in self.price_history.values()),
            'config': self.config,
            'positions': self.active_positions
        }
